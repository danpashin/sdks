// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.12.5 clang-1500.3.9.1.1)
// swift-module-flags: -target arm64-apple-ios17.4 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftUIKit -swift-version 5 -enforce-exclusivity=checked -O -library-level api -module-abi-name UIKit -enable-bare-slash-regex -user-module-version 7439.1.105 -module-name UIKit
@_exported import Accessibility
import CoreGraphics
import DataDetection
@_exported import DeveloperToolsSupport
import Dispatch
import Foundation
import QuartzCore
import Swift
import Symbols
@_exported import UIKit
@_exported import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
@available(iOS 17.0, tvOS 17.0, *)
public protocol UITraitDefinition {
  associatedtype Value
  static var defaultValue: Self.Value { get }
  static var identifier: Swift.String { get }
  static var name: Swift.String { get }
  static var affectsColorAppearance: Swift.Bool { get }
  static var _defaultValueRepresentsUnspecified: Swift.Bool { get }
  static var _isPrivate: Swift.Bool { get }
}
@available(iOS 17.0, tvOS 17.0, *)
public typealias UITrait = any UIKit.UITraitDefinition.Type
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UITraitDefinition {
  public static var identifier: Swift.String {
    get
  }
  public static var name: Swift.String {
    get
  }
  public static var affectsColorAppearance: Swift.Bool {
    get
  }
  public static var _defaultValueRepresentsUnspecified: Swift.Bool {
    get
  }
  public static var _isPrivate: Swift.Bool {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public protocol _UICustomRawRepresentableTraitDefinition : UIKit.UITraitDefinition {
  associatedtype _CustomRawValue
  static func _customRawValue(for value: Self.Value) -> Self._CustomRawValue
  static func _value(from customRawValue: Self._CustomRawValue) -> Self.Value?
}
@available(iOS 17.0, tvOS 17.0, *)
public protocol UIMutableTraits {
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == CoreFoundation.CGFloat { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == CoreFoundation.CGFloat? { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Double { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Double? { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Int { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Int? { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Bool { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == CoreFoundation.CGFloat { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == Swift.Double { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == Swift.Int { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == CoreFoundation.CGFloat { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == Swift.Double { get set }
  subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == Swift.Int { get set }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UITraitCollection {
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == CoreFoundation.CGFloat {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == CoreFoundation.CGFloat? {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Double {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Double? {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Int {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Int? {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Bool {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == CoreFoundation.CGFloat {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == Swift.Double {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == Swift.Int {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == CoreFoundation.CGFloat {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == Swift.Double {
    get
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == Swift.Int {
    get
  }
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition, T.Value == CoreFoundation.CGFloat
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition, T.Value == CoreFoundation.CGFloat?
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition, T.Value == Swift.Double
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition, T.Value == Swift.Double?
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition, T.Value == Swift.Int
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition, T.Value == Swift.Int?
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition, T.Value == Swift.Bool
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit._UICustomRawRepresentableTraitDefinition
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == CoreFoundation.CGFloat
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == Swift.Double
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == Swift.Int
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == CoreFoundation.CGFloat
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == Swift.Double
  public func replacing<T>(_ trait: T.Type, value: T.Value) -> UITraitCollection where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == Swift.Int
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition, T.Value == CoreFoundation.CGFloat
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition, T.Value == CoreFoundation.CGFloat?
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition, T.Value == Swift.Double
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition, T.Value == Swift.Double?
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition, T.Value == Swift.Int
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition, T.Value == Swift.Int?
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition, T.Value == Swift.Bool
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit._UICustomRawRepresentableTraitDefinition
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == CoreFoundation.CGFloat
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == Swift.Double
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == Swift.Int
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == CoreFoundation.CGFloat
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == Swift.Double
  convenience public init<T>(_ trait: T.Type, value: T.Value) where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == Swift.Int
  public typealias TraitMutations = (_ mutableTraits: inout any UIKit.UIMutableTraits) -> Swift.Void
  convenience public init(mutations: (_ mutableTraits: inout any UIKit.UIMutableTraits) -> Swift.Void)
  public func modifyingTraits(_ mutations: (_ mutableTraits: inout any UIKit.UIMutableTraits) -> Swift.Void) -> UITraitCollection
  public func changedTraits(from traitCollection: UITraitCollection?) -> [UIKit.UITrait]
  public static var systemTraitsAffectingColorAppearance: [UIKit.UITrait] {
    get
  }
  public static var systemTraitsAffectingImageLookup: [UIKit.UITrait] {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitOverrides : UIKit.UIMutableTraits {
  public func contains(_ trait: UIKit.UITrait) -> Swift.Bool
  public mutating func remove(_ trait: UIKit.UITrait)
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == CoreFoundation.CGFloat {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == CoreFoundation.CGFloat? {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Double {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Double? {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Int {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Int? {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value == Swift.Bool {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == CoreFoundation.CGFloat {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == Swift.Double {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit._UICustomRawRepresentableTraitDefinition, T._CustomRawValue == Swift.Int {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == CoreFoundation.CGFloat {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == Swift.Double {
    get
    set
  }
  public subscript<T>(trait: T.Type) -> T.Value where T : UIKit.UITraitDefinition, T.Value : Swift.RawRepresentable, T.Value.RawValue == Swift.Int {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UITraitOverrides : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
@_Concurrency.MainActor public protocol UITraitChangeObservable {
  typealias TraitChangeHandler<TraitEnvironment> = (_ traitEnvironment: TraitEnvironment, _ previousTraitCollection: UITraitCollection) -> Swift.Void where TraitEnvironment : UITraitEnvironment
  @discardableResult
  @_Concurrency.MainActor func registerForTraitChanges<TraitEnvironment>(_ traits: [UIKit.UITrait], handler: @escaping Self.TraitChangeHandler<TraitEnvironment>) -> any UITraitChangeRegistration where TraitEnvironment : UITraitEnvironment
  @discardableResult
  @_Concurrency.MainActor func registerForTraitChanges(_ traits: [UIKit.UITrait], target: Any, action: ObjectiveC.Selector) -> any UITraitChangeRegistration
  @discardableResult
  @_Concurrency.MainActor func registerForTraitChanges(_ traits: [UIKit.UITrait], action: ObjectiveC.Selector) -> any UITraitChangeRegistration
  @_Concurrency.MainActor func unregisterForTraitChanges(_ registration: any UITraitChangeRegistration)
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIView : UIKit.UITraitChangeObservable {
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges<Self>(_ traits: [UIKit.UITrait], handler: @escaping UIView.TraitChangeHandler<Self>) -> any UITraitChangeRegistration where Self : UITraitEnvironment
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges(_ traits: [UIKit.UITrait], target: Any, action: ObjectiveC.Selector) -> any UITraitChangeRegistration
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges(_ traits: [UIKit.UITrait], action: ObjectiveC.Selector) -> any UITraitChangeRegistration
  @_Concurrency.MainActor public func unregisterForTraitChanges(_ registration: any UITraitChangeRegistration)
  @_Concurrency.MainActor(unsafe) public var traitOverrides: UIKit.UITraitOverrides {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIViewController : UIKit.UITraitChangeObservable {
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges<Self>(_ traits: [UIKit.UITrait], handler: @escaping UIViewController.TraitChangeHandler<Self>) -> any UITraitChangeRegistration where Self : UITraitEnvironment
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges(_ traits: [UIKit.UITrait], target: Any, action: ObjectiveC.Selector) -> any UITraitChangeRegistration
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges(_ traits: [UIKit.UITrait], action: ObjectiveC.Selector) -> any UITraitChangeRegistration
  @_Concurrency.MainActor public func unregisterForTraitChanges(_ registration: any UITraitChangeRegistration)
  @_Concurrency.MainActor(unsafe) public var traitOverrides: UIKit.UITraitOverrides {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIPresentationController : UIKit.UITraitChangeObservable {
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges<Self>(_ traits: [UIKit.UITrait], handler: @escaping UIPresentationController.TraitChangeHandler<Self>) -> any UITraitChangeRegistration where Self : UITraitEnvironment
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges(_ traits: [UIKit.UITrait], target: Any, action: ObjectiveC.Selector) -> any UITraitChangeRegistration
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges(_ traits: [UIKit.UITrait], action: ObjectiveC.Selector) -> any UITraitChangeRegistration
  @_Concurrency.MainActor public func unregisterForTraitChanges(_ registration: any UITraitChangeRegistration)
  @_Concurrency.MainActor(unsafe) public var traitOverrides: UIKit.UITraitOverrides {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIWindowScene : UIKit.UITraitChangeObservable {
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges<Self>(_ traits: [UIKit.UITrait], handler: @escaping UIWindowScene.TraitChangeHandler<Self>) -> any UITraitChangeRegistration where Self : UITraitEnvironment
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges(_ traits: [UIKit.UITrait], target: Any, action: ObjectiveC.Selector) -> any UITraitChangeRegistration
  @discardableResult
  @_Concurrency.MainActor public func registerForTraitChanges(_ traits: [UIKit.UITrait], action: ObjectiveC.Selector) -> any UITraitChangeRegistration
  @_Concurrency.MainActor public func unregisterForTraitChanges(_ registration: any UITraitChangeRegistration)
  @_Concurrency.MainActor(unsafe) public var traitOverrides: UIKit.UITraitOverrides {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitUserInterfaceIdiom : UIKit.UITraitDefinition {
  public static let defaultValue: UIUserInterfaceIdiom
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UIUserInterfaceIdiom
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var userInterfaceIdiom: UIUserInterfaceIdiom {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitUserInterfaceStyle : UIKit.UITraitDefinition {
  public static let defaultValue: UIUserInterfaceStyle
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UIUserInterfaceStyle
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var userInterfaceStyle: UIUserInterfaceStyle {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitLayoutDirection : UIKit.UITraitDefinition {
  public static let defaultValue: UITraitEnvironmentLayoutDirection
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UITraitEnvironmentLayoutDirection
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var layoutDirection: UITraitEnvironmentLayoutDirection {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitDisplayScale : UIKit.UITraitDefinition {
  public static let defaultValue: CoreFoundation.CGFloat
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = CoreFoundation.CGFloat
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var displayScale: CoreFoundation.CGFloat {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitHorizontalSizeClass : UIKit.UITraitDefinition {
  public static let defaultValue: UIUserInterfaceSizeClass
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UIUserInterfaceSizeClass
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var horizontalSizeClass: UIUserInterfaceSizeClass {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitVerticalSizeClass : UIKit.UITraitDefinition {
  public static let defaultValue: UIUserInterfaceSizeClass
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UIUserInterfaceSizeClass
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var verticalSizeClass: UIUserInterfaceSizeClass {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitForceTouchCapability : UIKit.UITraitDefinition {
  public static let defaultValue: UIForceTouchCapability
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UIForceTouchCapability
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var forceTouchCapability: UIForceTouchCapability {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitPreferredContentSizeCategory : UIKit.UITraitDefinition {
  public static let defaultValue: UIContentSizeCategory
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UIContentSizeCategory
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var preferredContentSizeCategory: UIContentSizeCategory {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitDisplayGamut : UIKit.UITraitDefinition {
  public static let defaultValue: UIDisplayGamut
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UIDisplayGamut
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var displayGamut: UIDisplayGamut {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitAccessibilityContrast : UIKit.UITraitDefinition {
  public static let defaultValue: UIAccessibilityContrast
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UIAccessibilityContrast
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var accessibilityContrast: UIAccessibilityContrast {
    get
    set
  }
}
@available(iOS 17.0, *)
@available(tvOS, unavailable)
public struct UITraitUserInterfaceLevel : UIKit.UITraitDefinition {
  public static let defaultValue: UIUserInterfaceLevel
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UIUserInterfaceLevel
}
@available(iOS 17.0, *)
@available(tvOS, unavailable)
extension UIKit.UIMutableTraits {
  public var userInterfaceLevel: UIUserInterfaceLevel {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitLegibilityWeight : UIKit.UITraitDefinition {
  public static let defaultValue: UILegibilityWeight
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UILegibilityWeight
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var legibilityWeight: UILegibilityWeight {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitActiveAppearance : UIKit.UITraitDefinition {
  public static let defaultValue: UIUserInterfaceActiveAppearance
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UIUserInterfaceActiveAppearance
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var activeAppearance: UIUserInterfaceActiveAppearance {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitToolbarItemPresentationSize : UIKit.UITraitDefinition {
  public static let defaultValue: UINSToolbarItemPresentationSize
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UINSToolbarItemPresentationSize
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var toolbarItemPresentationSize: UINSToolbarItemPresentationSize {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitImageDynamicRange : UIKit.UITraitDefinition {
  public static let defaultValue: UIImage.DynamicRange
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UIImage.DynamicRange
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var imageDynamicRange: UIImage.DynamicRange {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, visionOS 1.0, *)
public struct UITraitSceneCaptureState : UIKit.UITraitDefinition {
  public static let defaultValue: UISceneCaptureState
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let affectsColorAppearance: Swift.Bool
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = UISceneCaptureState
}
@available(iOS 17.0, tvOS 17.0, visionOS 1.0, *)
extension UIKit.UIMutableTraits {
  public var sceneCaptureState: UISceneCaptureState {
    get
    set
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UITraitTypesettingLanguage : UIKit.UITraitDefinition {
  public static let defaultValue: Foundation.Locale.Language?
  public static let name: Swift.String
  public static let identifier: Swift.String
  public static let _defaultValueRepresentsUnspecified: Swift.Bool
  public static let _isPrivate: Swift.Bool
  public typealias Value = Foundation.Locale.Language?
}
@available(iOS 17.0, tvOS 17.0, *)
extension UITraitCollection {
  public var typesettingLanguage: Foundation.Locale.Language? {
    get
  }
  convenience public init(typesettingLanguage: Foundation.Locale.Language?)
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UITraitTypesettingLanguage : UIKit._UICustomRawRepresentableTraitDefinition {
  public static func _customRawValue(for value: Foundation.Locale.Language?) -> Swift.String?
  public static func _value(from customRawValue: Swift.String?) -> Foundation.Locale.Language??
  public typealias _CustomRawValue = Swift.String?
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIMutableTraits {
  public var typesettingLanguage: Foundation.Locale.Language? {
    get
    set
  }
}
extension UIViewController {
  @available(swift 5.1)
  @available(iOS 16.4, tvOS 16.4, *)
  @propertyWrapper public struct ViewLoading<Value> {
    @available(*, unavailable, message: "@UIViewController.ViewLoading can only be used on subclasses of UIViewController")
    public var wrappedValue: Value {
      get
      set
    }
    public init()
    public init(wrappedValue: Value)
    public static subscript<EnclosingSelf>(_enclosingInstance observed: EnclosingSelf, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, UIViewController.ViewLoading<Value>>) -> Value where EnclosingSelf : UIViewController {
      get
      set
    }
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewListCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var accessories: [UIKit.UICellAccessory] {
    get
    set
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UICellAccessory {
  public typealias ActionHandler = () -> Swift.Void
  public enum DisplayedState {
    case always
    case whenEditing
    case whenNotEditing
    public static func == (a: UIKit.UICellAccessory.DisplayedState, b: UIKit.UICellAccessory.DisplayedState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum LayoutDimension {
    case actual
    case standard
    case custom(CoreFoundation.CGFloat)
  }
  public struct DisclosureIndicatorOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil)
  }
  public static func disclosureIndicator(displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.DisclosureIndicatorOptions = DisclosureIndicatorOptions()) -> UIKit.UICellAccessory
  @available(iOS 15.4, tvOS 15.4, *)
  public struct DetailOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil)
  }
  @available(iOS 15.4, tvOS 15.4, *)
  public static func detail(displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.DetailOptions = DetailOptions(), actionHandler: UIKit.UICellAccessory.ActionHandler? = nil) -> UIKit.UICellAccessory
  public struct CheckmarkOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil)
  }
  public static func checkmark(displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.CheckmarkOptions = CheckmarkOptions()) -> UIKit.UICellAccessory
  public struct DeleteOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIColor?
    public var backgroundColor: UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, backgroundColor: UIColor? = nil)
  }
  public static func delete(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.DeleteOptions = DeleteOptions(), actionHandler: UIKit.UICellAccessory.ActionHandler? = nil) -> UIKit.UICellAccessory
  public struct InsertOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIColor?
    public var backgroundColor: UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, backgroundColor: UIColor? = nil)
  }
  public static func insert(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.InsertOptions = InsertOptions(), actionHandler: UIKit.UICellAccessory.ActionHandler? = nil) -> UIKit.UICellAccessory
  public struct ReorderOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIColor?
    public var showsVerticalSeparator: Swift.Bool
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, showsVerticalSeparator: Swift.Bool? = nil)
  }
  public static func reorder(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.ReorderOptions = ReorderOptions()) -> UIKit.UICellAccessory
  public struct MultiselectOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIColor?
    public var backgroundColor: UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, backgroundColor: UIColor? = nil)
  }
  public static func multiselect(displayed: UIKit.UICellAccessory.DisplayedState = .whenEditing, options: UIKit.UICellAccessory.MultiselectOptions = MultiselectOptions()) -> UIKit.UICellAccessory
  public struct OutlineDisclosureOptions {
    public enum Style {
      case automatic
      case header
      case cell
      public static func == (a: UIKit.UICellAccessory.OutlineDisclosureOptions.Style, b: UIKit.UICellAccessory.OutlineDisclosureOptions.Style) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var style: UIKit.UICellAccessory.OutlineDisclosureOptions.Style
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIColor?
    public init(style: UIKit.UICellAccessory.OutlineDisclosureOptions.Style? = nil, isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil)
  }
  public static func outlineDisclosure(displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.OutlineDisclosureOptions = OutlineDisclosureOptions(), actionHandler: UIKit.UICellAccessory.ActionHandler? = nil) -> UIKit.UICellAccessory
  public typealias MenuSelectedElementDidChangeHandler = (UIMenu) -> Swift.Void
  @available(iOS 16.0, *)
  public struct PopUpMenuOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIColor?
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil)
  }
  @available(iOS 16.0, *)
  public static func popUpMenu(_ menu: UIMenu, displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.PopUpMenuOptions = PopUpMenuOptions(), selectedElementDidChangeHandler: UIKit.UICellAccessory.MenuSelectedElementDidChangeHandler? = nil) -> UIKit.UICellAccessory
  public struct LabelOptions {
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIColor?
    public var font: UIFont
    public var adjustsFontForContentSizeCategory: Swift.Bool
    public init(isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, font: UIFont? = nil, adjustsFontForContentSizeCategory: Swift.Bool? = nil)
  }
  public static func label(text: Swift.String, displayed: UIKit.UICellAccessory.DisplayedState = .always, options: UIKit.UICellAccessory.LabelOptions = LabelOptions()) -> UIKit.UICellAccessory
  public enum Placement {
    public typealias Position = (_ accessories: [UIKit.UICellAccessory]) -> Swift.Int
    public static func position(before accessory: UIKit.UICellAccessory) -> UIKit.UICellAccessory.Placement.Position
    public static func position(after accessory: UIKit.UICellAccessory) -> UIKit.UICellAccessory.Placement.Position
    case leading(displayed: UIKit.UICellAccessory.DisplayedState = .always, at: UIKit.UICellAccessory.Placement.Position = { $0.count })
    case trailing(displayed: UIKit.UICellAccessory.DisplayedState = .always, at: UIKit.UICellAccessory.Placement.Position = { _ in 0 })
  }
  public struct CustomViewConfiguration {
    public let customView: UIView
    public let placement: UIKit.UICellAccessory.Placement
    public var isHidden: Swift.Bool
    public var reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension
    public var tintColor: UIColor?
    public var maintainsFixedSize: Swift.Bool
    public init(customView: UIView, placement: UIKit.UICellAccessory.Placement, isHidden: Swift.Bool? = nil, reservedLayoutWidth: UIKit.UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, maintainsFixedSize: Swift.Bool? = nil)
  }
  public static func customView(configuration: UIKit.UICellAccessory.CustomViewConfiguration) -> UIKit.UICellAccessory
  public enum AccessoryType : Swift.Hashable {
    case disclosureIndicator
    case outlineDisclosure
    case checkmark
    case delete
    case insert
    case reorder
    case multiselect
    case label
    case customView(UIView)
    @available(iOS 15.4, tvOS 15.4, *)
    case detail
    @available(iOS 16.0, *)
    case popUpMenu
    public static func == (lhs: UIKit.UICellAccessory.AccessoryType, rhs: UIKit.UICellAccessory.AccessoryType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let accessoryType: UIKit.UICellAccessory.AccessoryType
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
public struct UIShape : UIKit.UIShapeProvider {
  public static var rect: UIKit.UIShape {
    get
  }
  public static var capsule: UIKit.UIShape {
    get
  }
  public static var circle: UIKit.UIShape {
    get
  }
  public static func rect(cornerRadius: CoreFoundation.CGFloat, cornerCurve: UICornerCurve = .automatic, maskedCorners: UIRectCorner = .allCorners) -> UIKit.UIShape
  public static func fixedRect(_ rect: CoreFoundation.CGRect, cornerRadius: CoreFoundation.CGFloat = 0, cornerCurve: UICornerCurve = .automatic, maskedCorners: UIRectCorner = .allCorners) -> UIKit.UIShape
  public static func path(_ path: UIBezierPath) -> UIKit.UIShape
  public func inset(by insets: UIEdgeInsets) -> UIKit.UIShape
  public func inset(by amount: CoreFoundation.CGFloat) -> UIKit.UIShape
  public init(_ provider: some UIShapeProvider)
  public static func == (a: UIKit.UIShape, b: UIKit.UIShape) -> Swift.Bool
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
extension UIKit.UIShape {
  public struct ResolutionContext {
    public var contentShape: UIKit.UIShape.Resolved
  }
  public func resolve(in context: UIKit.UIShape.ResolutionContext) -> UIKit.UIShape.Resolved
  public struct Resolved : Swift.Equatable {
    public let shape: UIKit.UIShape
    public var boundingRect: CoreFoundation.CGRect {
      get
    }
    public var path: UIBezierPath {
      get
    }
    public func inset(by insets: UIEdgeInsets) -> UIKit.UIShape.Resolved
    public func inset(by amount: CoreFoundation.CGFloat) -> UIKit.UIShape.Resolved
    public static func == (lhs: UIKit.UIShape.Resolved, rhs: UIKit.UIShape.Resolved) -> Swift.Bool
  }
}
@available(*, unavailable)
extension UIKit.UIShape : Swift.Sendable {
}
@available(*, unavailable)
extension UIKit.UIShape.Resolved : Swift.Sendable {
}
@available(*, unavailable)
extension UIKit.UIShape.ResolutionContext : Swift.Sendable {
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
public protocol UIShapeProvider : Swift.Equatable {
  func resolve(in context: Self.Context) -> Self.Resolved
  typealias Context = UIKit.UIShape.ResolutionContext
  typealias Resolved = UIKit.UIShape.Resolved
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
extension UICornerCurve : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
extension UIKit.UIShape : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
extension UIKit.UIShape.Resolved : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(iOS 15.0, tvOS 15.0, *)
public struct UIConfigurationTextAttributesTransformer {
  public let transform: (Foundation.AttributeContainer) -> Foundation.AttributeContainer
  public init(_ transform: @escaping (Foundation.AttributeContainer) -> Foundation.AttributeContainer)
  public func callAsFunction(_ input: Foundation.AttributeContainer) -> Foundation.AttributeContainer
}
@available(iOS 15.0, tvOS 15.0, *)
extension UIButton {
  public struct Configuration : Swift.Hashable {
    public enum Size {
      case mini
      case small
      case medium
      case large
      public static func == (a: UIButton.Configuration.Size, b: UIButton.Configuration.Size) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum TitleAlignment {
      case automatic
      case leading
      case center
      case trailing
      public static func == (a: UIButton.Configuration.TitleAlignment, b: UIButton.Configuration.TitleAlignment) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum CornerStyle {
      case fixed
      case dynamic
      case small
      case medium
      case large
      case capsule
      public static func == (a: UIButton.Configuration.CornerStyle, b: UIButton.Configuration.CornerStyle) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum MacIdiomStyle {
      case automatic
      case bordered
      case borderless
      case borderlessTinted
      public static func == (a: UIButton.Configuration.MacIdiomStyle, b: UIButton.Configuration.MacIdiomStyle) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @available(iOS 16.0, tvOS 16.0, *)
    public enum Indicator {
      case automatic
      case none
      case popup
      public static func == (a: UIButton.Configuration.Indicator, b: UIButton.Configuration.Indicator) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static func plain() -> UIButton.Configuration
    public static func tinted() -> UIButton.Configuration
    public static func gray() -> UIButton.Configuration
    public static func filled() -> UIButton.Configuration
    public static func borderless() -> UIButton.Configuration
    public static func bordered() -> UIButton.Configuration
    public static func borderedTinted() -> UIButton.Configuration
    public static func borderedProminent() -> UIButton.Configuration
    public func updated(for button: UIButton) -> UIButton.Configuration
    public var background: UIKit.UIBackgroundConfiguration {
      get
      set
    }
    public var cornerStyle: UIButton.Configuration.CornerStyle {
      get
      set
    }
    public var buttonSize: UIButton.Configuration.Size {
      get
      set
    }
    public var macIdiomStyle: UIButton.Configuration.MacIdiomStyle {
      get
      set
    }
    public var baseForegroundColor: UIColor? {
      get
      set
    }
    public var baseBackgroundColor: UIColor? {
      get
      set
    }
    public var image: UIImage? {
      get
      set
    }
    public var imageColorTransformer: UIKit.UIConfigurationColorTransformer? {
      get
      set
    }
    public var preferredSymbolConfigurationForImage: UIImage.SymbolConfiguration? {
      get
      set
    }
    public var showsActivityIndicator: Swift.Bool {
      get
      set
    }
    public var activityIndicatorColorTransformer: UIKit.UIConfigurationColorTransformer? {
      get
      set
    }
    public var title: Swift.String? {
      get
      set
    }
    public var attributedTitle: Foundation.AttributedString? {
      get
      set
    }
    public var titleTextAttributesTransformer: UIKit.UIConfigurationTextAttributesTransformer? {
      get
      set
    }
    public var subtitle: Swift.String? {
      get
      set
    }
    public var attributedSubtitle: Foundation.AttributedString? {
      get
      set
    }
    public var subtitleTextAttributesTransformer: UIKit.UIConfigurationTextAttributesTransformer? {
      get
      set
    }
    @available(iOS 16.0, tvOS 16.0, *)
    public var indicator: UIButton.Configuration.Indicator {
      get
      set
    }
    @available(iOS 16.0, tvOS 16.0, *)
    public var indicatorColorTransformer: UIKit.UIConfigurationColorTransformer? {
      get
      set
    }
    public var contentInsets: NSDirectionalEdgeInsets {
      get
      set
    }
    public mutating func setDefaultContentInsets()
    public var imagePlacement: NSDirectionalRectEdge {
      get
      set
    }
    public var imagePadding: CoreFoundation.CGFloat {
      get
      set
    }
    public var titlePadding: CoreFoundation.CGFloat {
      get
      set
    }
    public var titleAlignment: UIButton.Configuration.TitleAlignment {
      get
      set
    }
    public var automaticallyUpdateForSelection: Swift.Bool {
      get
      set
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIButton.Configuration, b: UIButton.Configuration) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) convenience public init(configuration: UIButton.Configuration, primaryAction: UIAction? = nil)
  @_Concurrency.MainActor(unsafe) public var configuration: UIButton.Configuration? {
    get
    set
  }
}
@available(iOS 15.0, tvOS 15.0, *)
extension UIButton.Configuration {
  public var titleLineBreakMode: NSLineBreakMode {
    get
    set
  }
  public var subtitleLineBreakMode: NSLineBreakMode {
    get
    set
  }
  public var imageReservation: CoreFoundation.CGFloat {
    get
    set
  }
}
@available(iOS 15.0, tvOS 15.0, *)
extension UIButton.Configuration : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> __UIButtonConfiguration
  public static func _forceBridgeFromObjectiveC(_ input: __UIButtonConfiguration, result: inout UIButton.Configuration?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: __UIButtonConfiguration, result: inout UIButton.Configuration?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _config: __UIButtonConfiguration?) -> UIButton.Configuration
  public typealias _ObjectiveCType = __UIButtonConfiguration
}
@available(iOS 16.0, *)
extension UIWindowScene.GeometryPreferences.iOS {
  public var interfaceOrientations: UIInterfaceOrientationMask? {
    get
    set
  }
}
@available(macCatalyst 16.0, *)
extension UIWindowScene.GeometryPreferences.Mac {
  public var systemFrame: CoreFoundation.CGRect? {
    get
    set
  }
}
extension UIControl {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public func enumerateEventHandlers(_ iterator: (UIAction?, (Any?, ObjectiveC.Selector)?, UIControl.Event, inout Swift.Bool) -> Swift.Void)
}
extension UIButton {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(type buttonType: UIButton.ButtonType = .system, primaryAction: UIAction?)
}
@available(iOS 16.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol UINavigationItemRenameDelegate : AnyObject {
  func navigationItem(_: UINavigationItem, didEndRenamingWith title: Swift.String)
  func navigationItemShouldBeginRenaming(_: UINavigationItem) -> Swift.Bool
  func navigationItem(_: UINavigationItem, willBeginRenamingWith suggestedTitle: Swift.String, selectedRange: Swift.Range<Swift.String.Index>) -> (Swift.String, Swift.Range<Swift.String.Index>)
  func navigationItem(_: UINavigationItem, shouldEndRenamingWith title: Swift.String) -> Swift.Bool
}
extension UIKit.UINavigationItemRenameDelegate {
  public func navigationItemShouldBeginRenaming(_ navigationItem: UINavigationItem) -> Swift.Bool
  public func navigationItem(_ navigationItem: UINavigationItem, willBeginRenamingWith suggestedTitle: Swift.String, selectedRange: Swift.Range<Swift.String.Index>) -> (Swift.String, Swift.Range<Swift.String.Index>)
  public func navigationItem(_ navigationItem: UINavigationItem, shouldEndRenamingWith title: Swift.String) -> Swift.Bool
}
extension UINavigationItem {
  @available(iOS 16.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @_Concurrency.MainActor(unsafe) weak public var renameDelegate: (any UIKit.UINavigationItemRenameDelegate)? {
    get
    set(renameDelegate)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var contentConfiguration: (any UIKit.UIContentConfiguration)? {
    get
    set(config)
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewListCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public func defaultContentConfiguration() -> UIKit.UIListContentConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var contentConfiguration: (any UIKit.UIContentConfiguration)? {
    get
    set(config)
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public func defaultContentConfiguration() -> UIKit.UIListContentConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var contentConfiguration: (any UIKit.UIContentConfiguration)? {
    get
    set(config)
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public func defaultContentConfiguration() -> UIKit.UIListContentConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentView : UIKit.UIContentView {
  @available(iOS 16.0, tvOS 16.0, *)
  @_Concurrency.MainActor public func supports(_ configuration: any UIKit.UIContentConfiguration) -> Swift.Bool
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor public var configuration: any UIKit.UIContentConfiguration {
    get
    set(config)
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(configuration: UIKit.UIListContentConfiguration)
}
@available(iOS 14.0, tvOS 14.0, *)
@_Concurrency.MainActor public protocol UIContentView : ObjectiveC.NSObjectProtocol {
  @_Concurrency.MainActor var configuration: any UIKit.UIContentConfiguration { get set }
  @available(iOS 16.0, tvOS 16.0, *)
  @_Concurrency.MainActor func supports(_ configuration: any UIKit.UIContentConfiguration) -> Swift.Bool
}
@available(iOS 16.0, tvOS 16.0, *)
extension UIKit.UIContentView {
  @_Concurrency.MainActor public func supports(_ configuration: any UIKit.UIContentConfiguration) -> Swift.Bool
}
@available(iOS 14.0, tvOS 14.0, *)
public protocol UIContentConfiguration {
  @_Concurrency.MainActor func makeContentView() -> any UIView & UIKit.UIContentView
  func updated(for state: any UIKit.UIConfigurationState) -> Self
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIListContentConfiguration : UIKit.UIContentConfiguration, Swift.Hashable {
  public struct ImageProperties : Swift.Hashable {
    public var preferredSymbolConfiguration: UIImage.SymbolConfiguration? {
      get
      set(preferredSymbolConfiguration)
    }
    public var tintColor: UIColor? {
      get
      set(tintColor)
    }
    public var tintColorTransformer: UIKit.UIConfigurationColorTransformer? {
      get
      set(tintColorTransformer)
    }
    public func resolvedTintColor(for tintColor: UIColor) -> UIColor
    public var cornerRadius: CoreFoundation.CGFloat {
      get
      set(cornerRadius)
    }
    public var maximumSize: CoreFoundation.CGSize {
      get
      set(maximumSize)
    }
    public var reservedLayoutSize: CoreFoundation.CGSize {
      get
      set(reservedLayoutSize)
    }
    public var accessibilityIgnoresInvertColors: Swift.Bool {
      get
      set(accessibilityIgnoresInvertColors)
    }
    public static let standardDimension: CoreFoundation.CGFloat
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIListContentConfiguration.ImageProperties, b: UIKit.UIListContentConfiguration.ImageProperties) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct TextProperties : Swift.Hashable {
    public enum TextAlignment : Swift.Hashable {
      case natural
      case center
      case justified
      public static func == (a: UIKit.UIListContentConfiguration.TextProperties.TextAlignment, b: UIKit.UIListContentConfiguration.TextProperties.TextAlignment) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum TextTransform : Swift.Hashable {
      case none
      case uppercase
      case lowercase
      case capitalized
      public static func == (a: UIKit.UIListContentConfiguration.TextProperties.TextTransform, b: UIKit.UIListContentConfiguration.TextProperties.TextTransform) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var font: UIFont {
      get
      set(font)
    }
    public var color: UIColor {
      get
      set(color)
    }
    public var colorTransformer: UIKit.UIConfigurationColorTransformer? {
      get
      set(colorTransformer)
    }
    public func resolvedColor() -> UIColor
    public var alignment: UIKit.UIListContentConfiguration.TextProperties.TextAlignment {
      get
      set(alignment)
    }
    public var lineBreakMode: NSLineBreakMode {
      get
      set(lineBreakMode)
    }
    public var numberOfLines: Swift.Int {
      get
      set(numberOfLines)
    }
    public var adjustsFontSizeToFitWidth: Swift.Bool {
      get
      set(adjustsFontSizeToFitWidth)
    }
    public var minimumScaleFactor: CoreFoundation.CGFloat {
      get
      set(minimumScaleFactor)
    }
    public var allowsDefaultTighteningForTruncation: Swift.Bool {
      get
      set(allowsDefaultTighteningForTruncation)
    }
    public var adjustsFontForContentSizeCategory: Swift.Bool {
      get
      set(adjustsFontForContentSizeCategory)
    }
    @available(macCatalyst 16.0, *)
    public var showsExpansionTextWhenTruncated: Swift.Bool {
      get
      set(showsExpansionTextWhenTruncated)
    }
    public var transform: UIKit.UIListContentConfiguration.TextProperties.TextTransform {
      get
      set(transform)
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIListContentConfiguration.TextProperties, b: UIKit.UIListContentConfiguration.TextProperties) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func cell() -> UIKit.UIListContentConfiguration
  public static func subtitleCell() -> UIKit.UIListContentConfiguration
  public static func valueCell() -> UIKit.UIListContentConfiguration
  public static func plainHeader() -> UIKit.UIListContentConfiguration
  public static func plainFooter() -> UIKit.UIListContentConfiguration
  public static func groupedHeader() -> UIKit.UIListContentConfiguration
  public static func groupedFooter() -> UIKit.UIListContentConfiguration
  @available(iOS 15.0, *)
  public static func prominentInsetGroupedHeader() -> UIKit.UIListContentConfiguration
  @available(iOS 15.0, *)
  public static func extraProminentInsetGroupedHeader() -> UIKit.UIListContentConfiguration
  public static func sidebarCell() -> UIKit.UIListContentConfiguration
  public static func sidebarSubtitleCell() -> UIKit.UIListContentConfiguration
  public static func accompaniedSidebarCell() -> UIKit.UIListContentConfiguration
  public static func accompaniedSidebarSubtitleCell() -> UIKit.UIListContentConfiguration
  public static func sidebarHeader() -> UIKit.UIListContentConfiguration
  @_Concurrency.MainActor public func makeContentView() -> any UIView & UIKit.UIContentView
  public func updated(for state: any UIKit.UIConfigurationState) -> UIKit.UIListContentConfiguration
  public var image: UIImage? {
    get
    set(image)
  }
  public var imageProperties: UIKit.UIListContentConfiguration.ImageProperties {
    get
    set(imageProperties)
  }
  public var text: Swift.String? {
    get
    set(text)
  }
  public var attributedText: Foundation.NSAttributedString? {
    get
    set(attributedText)
  }
  public var textProperties: UIKit.UIListContentConfiguration.TextProperties {
    get
    set(textProperties)
  }
  public var secondaryText: Swift.String? {
    get
    set(secondaryText)
  }
  public var secondaryAttributedText: Foundation.NSAttributedString? {
    get
    set(secondaryAttributedText)
  }
  public var secondaryTextProperties: UIKit.UIListContentConfiguration.TextProperties {
    get
    set(secondaryTextProperties)
  }
  public var axesPreservingSuperviewLayoutMargins: UIAxis {
    get
    set(axesPreservingSuperviewLayoutMargins)
  }
  public var directionalLayoutMargins: NSDirectionalEdgeInsets {
    get
    set(directionalLayoutMargins)
  }
  public var prefersSideBySideTextAndSecondaryText: Swift.Bool {
    get
    set(prefersSideBySideTextAndSecondaryText)
  }
  public var imageToTextPadding: CoreFoundation.CGFloat {
    get
    set(imageToTextPadding)
  }
  public var textToSecondaryTextHorizontalPadding: CoreFoundation.CGFloat {
    get
    set(textToSecondaryTextHorizontalPadding)
  }
  public var textToSecondaryTextVerticalPadding: CoreFoundation.CGFloat {
    get
    set(textToSecondaryTextVerticalPadding)
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIListContentConfiguration, b: UIKit.UIListContentConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIListContentConfiguration.ImageProperties : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIListContentConfiguration.TextProperties : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIListContentConfiguration : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(tvOS, unavailable)
@available(visionOS, unavailable)
extension UISheetPresentationController.Detent {
  @available(iOS 16.0, *)
  @_Concurrency.MainActor(unsafe) public static func custom(identifier: UISheetPresentationController.Detent.Identifier? = nil, resolver: @escaping (_ context: any UISheetPresentationControllerDetentResolutionContext) -> CoreFoundation.CGFloat?) -> UISheetPresentationController.Detent
  @available(iOS 16.0, *)
  @_Concurrency.MainActor(unsafe) public func resolvedValue(in context: any UISheetPresentationControllerDetentResolutionContext) -> CoreFoundation.CGFloat?
}
@available(tvOS, unavailable)
extension UISheetPresentationController {
  @available(iOS 15.0, *)
  @available(visionOS, unavailable)
  @_Concurrency.MainActor(unsafe) public var preferredCornerRadius: CoreFoundation.CGFloat? {
    get
    set
  }
}
extension Foundation.IndexPath {
  public init(row: Swift.Int, section: Swift.Int)
  public init(item: Swift.Int, section: Swift.Int)
  public var section: Swift.Int {
    get
    set
  }
  public var row: Swift.Int {
    get
    set
  }
  public var item: Swift.Int {
    get
    set
  }
}
extension Foundation.URLResourceValues {
  @available(iOS, introduced: 8.0, deprecated: 15.0, message: "Use the QuickLookThumbnailing framework and extension point instead")
  @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "Use the QuickLookThumbnailing framework and extension point instead")
  public var thumbnailDictionary: [Foundation.URLThumbnailDictionaryItem : UIImage]? {
    get
  }
}
extension UIEdgeInsets : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIEdgeInsets?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIEdgeInsets?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> UIEdgeInsets
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension NSDirectionalEdgeInsets : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout NSDirectionalEdgeInsets?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout NSDirectionalEdgeInsets?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> NSDirectionalEdgeInsets
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension UIOffset : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIOffset?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout UIOffset?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> UIOffset
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIImageView {
  @_Concurrency.MainActor(unsafe) public func addSymbolEffect(_ effect: some Symbols.SymbolEffect & Symbols.DiscreteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true, completion: UIKit.UISymbolEffectCompletion? = nil)
  @_Concurrency.MainActor(unsafe) public func addSymbolEffect(_ effect: some Symbols.SymbolEffect & Symbols.IndefiniteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true, completion: UIKit.UISymbolEffectCompletion? = nil)
  @_Concurrency.MainActor(unsafe) public func addSymbolEffect(_ effect: some Symbols.SymbolEffect & Symbols.DiscreteSymbolEffect & Symbols.IndefiniteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true, completion: UIKit.UISymbolEffectCompletion? = nil)
  @_Concurrency.MainActor(unsafe) public func removeSymbolEffect(ofType effect: some Symbols.SymbolEffect & Symbols.DiscreteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true, completion: UIKit.UISymbolEffectCompletion? = nil)
  @_Concurrency.MainActor(unsafe) public func removeSymbolEffect(ofType effect: some Symbols.SymbolEffect & Symbols.IndefiniteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true, completion: UIKit.UISymbolEffectCompletion? = nil)
  @_Concurrency.MainActor(unsafe) public func removeSymbolEffect(ofType effect: some Symbols.SymbolEffect & Symbols.DiscreteSymbolEffect & Symbols.IndefiniteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true, completion: UIKit.UISymbolEffectCompletion? = nil)
  @_Concurrency.MainActor(unsafe) public func removeAllSymbolEffects(options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func setSymbolImage(_ image: UIImage, contentTransition: some Symbols.SymbolEffect & Symbols.ContentTransitionSymbolEffect, options: Symbols.SymbolEffectOptions = .default, completion: UIKit.UISymbolEffectCompletion? = nil)
}
@available(iOS 17.0, tvOS 17.0, *)
public typealias UISymbolEffectCompletion = (UIKit.UISymbolEffectCompletionContext) -> Swift.Void
@available(iOS 17.0, tvOS 17.0, *)
@_Concurrency.MainActor public struct UISymbolEffectCompletionContext {
  @_Concurrency.MainActor public var isFinished: Swift.Bool {
    get
  }
  @_Concurrency.MainActor weak public var sender: Swift.AnyObject? {
    get
  }
  @_Concurrency.MainActor public var effect: any Symbols.SymbolEffect {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIWindowScene.ActivationRequestOptions {
  @_Concurrency.MainActor(unsafe) public var placement: (any UIKit.UIWindowScenePlacement)? {
    get
    set
  }
}
@available(iOS 16.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension UIEditMenuConfiguration {
  @_Concurrency.MainActor(unsafe) public var identifier: Swift.AnyHashable {
    get
  }
  @_Concurrency.MainActor(unsafe) convenience public init(identifier: Swift.AnyHashable?, sourcePoint: CoreFoundation.CGPoint)
}
@available(iOS 14.0, *)
@_Concurrency.MainActor(unsafe) open class UIIndirectScribbleInteraction<Delegate> : ObjectiveC.NSObject, UIInteraction where Delegate : UIKit.UIIndirectScribbleInteractionDelegate {
  @_Concurrency.MainActor(unsafe) @objc weak public var view: UIView? {
    get
  }
  @_Concurrency.MainActor(unsafe) weak public var delegate: Delegate? {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc public func willMove(to view: UIView?)
  @_Concurrency.MainActor(unsafe) @objc public func didMove(to view: UIView?)
  @_Concurrency.MainActor(unsafe) public init(delegate: Delegate)
  @_Concurrency.MainActor(unsafe) public var isHandlingWriting: Swift.Bool {
    get
  }
  @objc deinit
}
@available(iOS 14.0, *)
public protocol UIIndirectScribbleInteractionDelegate : ObjectiveC.NSObjectProtocol {
  associatedtype ElementIdentifier : Swift.Hashable = Swift.String
  func indirectScribbleInteraction(_ interaction: any UIInteraction, requestElementsIn rect: CoreFoundation.CGRect, completion: @escaping ([Self.ElementIdentifier]) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  @_Concurrency.MainActor func indirectScribbleInteraction(_ interaction: any UIInteraction, requestElementsIn rect: CoreFoundation.CGRect) async -> [Self.ElementIdentifier]
  #endif
  func indirectScribbleInteraction(_ interaction: any UIInteraction, isElementFocused elementIdentifier: Self.ElementIdentifier) -> Swift.Bool
  func indirectScribbleInteraction(_ interaction: any UIInteraction, frameForElement elementIdentifier: Self.ElementIdentifier) -> CoreFoundation.CGRect
  func indirectScribbleInteraction(_ interaction: any UIInteraction, focusElementIfNeeded elementIdentifier: Self.ElementIdentifier, referencePoint focusReferencePoint: CoreFoundation.CGPoint, completion: @escaping ((any UIResponder & UITextInput)?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  @_Concurrency.MainActor func indirectScribbleInteraction(_ interaction: any UIInteraction, focusElementIfNeeded elementIdentifier: Self.ElementIdentifier, referencePoint focusReferencePoint: CoreFoundation.CGPoint) async -> (any UIResponder & UITextInput)?
  #endif
  func indirectScribbleInteraction(_ interaction: any UIInteraction, shouldDelayFocusForElement elementIdentifier: Self.ElementIdentifier) -> Swift.Bool
  func indirectScribbleInteraction(_ interaction: any UIInteraction, willBeginWritingInElement elementIdentifier: Self.ElementIdentifier)
  func indirectScribbleInteraction(_ interaction: any UIInteraction, didFinishWritingInElement elementIdentifier: Self.ElementIdentifier)
}
@available(iOS 14.0, *)
extension UIKit.UIIndirectScribbleInteractionDelegate {
  public func indirectScribbleInteraction(_ interaction: any UIInteraction, willBeginWritingInElement elementIdentifier: Self.ElementIdentifier)
  public func indirectScribbleInteraction(_ interaction: any UIInteraction, didFinishWritingInElement elementIdentifier: Self.ElementIdentifier)
  public func indirectScribbleInteraction(_ interaction: any UIInteraction, shouldDelayFocusForElement elementIdentifier: Self.ElementIdentifier) -> Swift.Bool
}
@available(iOS 15.0, *)
extension UIKit.UIIndirectScribbleInteractionDelegate {
  #if compiler(>=5.3) && $AsyncAwait
  @_Concurrency.MainActor public func indirectScribbleInteraction(_ interaction: any UIInteraction, requestElementsIn rect: CoreFoundation.CGRect) async -> [Self.ElementIdentifier]
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @_Concurrency.MainActor public func indirectScribbleInteraction(_ interaction: any UIInteraction, focusElementIfNeeded elementIdentifier: Self.ElementIdentifier, referencePoint focusReferencePoint: CoreFoundation.CGPoint) async -> (any UIResponder & UITextInput)?
  #endif
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionView {
  public struct CellRegistration<Cell, Item> where Cell : UICollectionViewCell {
    public typealias Handler = (_ cell: Cell, _ indexPath: Foundation.IndexPath, _ itemIdentifier: Item) -> Swift.Void
    public init(handler: @escaping UICollectionView.CellRegistration<Cell, Item>.Handler)
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "Loading Interface Builder products will not be supported in a future version of visionOS.")
    public init(cellNib: UINib, handler: @escaping UICollectionView.CellRegistration<Cell, Item>.Handler)
  }
  public struct SupplementaryRegistration<Supplementary> where Supplementary : UICollectionReusableView {
    public typealias Handler = (_ supplementaryView: Supplementary, _ elementKind: Swift.String, _ indexPath: Foundation.IndexPath) -> Swift.Void
    public init(elementKind: Swift.String, handler: @escaping UICollectionView.SupplementaryRegistration<Supplementary>.Handler)
    @available(visionOS, introduced: 1.0, deprecated: 1.0, message: "Loading Interface Builder products will not be supported in a future version of visionOS.")
    public init(supplementaryNib: UINib, elementKind: Swift.String, handler: @escaping UICollectionView.SupplementaryRegistration<Supplementary>.Handler)
  }
  @_Concurrency.MainActor(unsafe) public func dequeueConfiguredReusableCell<Cell, Item>(using registration: UICollectionView.CellRegistration<Cell, Item>, for indexPath: Foundation.IndexPath, item: Item?) -> Cell where Cell : UICollectionViewCell
  @_Concurrency.MainActor(unsafe) public func dequeueConfiguredReusableSupplementary<Supplementary>(using registration: UICollectionView.SupplementaryRegistration<Supplementary>, for indexPath: Foundation.IndexPath) -> Supplementary where Supplementary : UICollectionReusableView
}
@available(*, unavailable)
extension UICollectionView.CellRegistration : Swift.Sendable {
}
@available(*, unavailable)
extension UICollectionView.SupplementaryRegistration : Swift.Sendable {
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UISceneSessionActivationRequest : Swift.Hashable {
  public var role: UISceneSession.Role {
    get
  }
  public var session: UISceneSession? {
    get
  }
  public var userActivity: Foundation.NSUserActivity? {
    get
    set
  }
  public var options: UIScene.ActivationRequestOptions? {
    get
    set
  }
  public init(role: UISceneSession.Role = .windowApplication, userActivity: Foundation.NSUserActivity? = nil, options: UIScene.ActivationRequestOptions? = nil)
  public init(session: UISceneSession, userActivity: Foundation.NSUserActivity? = nil, options: UIScene.ActivationRequestOptions? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UISceneSessionActivationRequest, b: UIKit.UISceneSessionActivationRequest) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIApplication {
  @_Concurrency.MainActor(unsafe) public func activateSceneSession(for request: UIKit.UISceneSessionActivationRequest, errorHandler: ((any Swift.Error) -> Swift.Void)? = nil)
}
extension UIPasteboard {
  @available(iOS 15.0, *)
  public struct DetectedValues {
    public var patterns: Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>> {
      get
    }
    public var probableWebURL: Swift.String {
      get
    }
    public var probableWebSearch: Swift.String {
      get
    }
    public var number: Swift.Double? {
      get
    }
    public var links: [DataDetection.DDMatchLink] {
      get
    }
    public var phoneNumbers: [DataDetection.DDMatchPhoneNumber] {
      get
    }
    public var emailAddresses: [DataDetection.DDMatchEmailAddress] {
      get
    }
    public var postalAddresses: [DataDetection.DDMatchPostalAddress] {
      get
    }
    public var calendarEvents: [DataDetection.DDMatchCalendarEvent] {
      get
    }
    public var shipmentTrackingNumbers: [DataDetection.DDMatchShipmentTrackingNumber] {
      get
    }
    public var flightNumbers: [DataDetection.DDMatchFlightNumber] {
      get
    }
    public var moneyAmounts: [DataDetection.DDMatchMoneyAmount] {
      get
    }
  }
}
extension UIPasteboard {
  @available(iOS, introduced: 14.0, deprecated: 15.0)
  @available(visionOS, introduced: 1.0, deprecated: 1.0)
  public func detectPatterns(for patterns: Swift.Set<UIPasteboard.DetectionPattern>, completionHandler: @escaping (Swift.Result<Swift.Set<UIPasteboard.DetectionPattern>, any Swift.Error>) -> ())
  @available(iOS 15.0, *)
  public func detectPatterns(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>, completionHandler: @escaping (Swift.Result<Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>, any Swift.Error>) -> ())
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  public func detectedPatterns(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>) async throws -> Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>
  #endif
  @available(iOS, introduced: 14.0, deprecated: 15.0)
  @available(visionOS, introduced: 1.0, deprecated: 1.0)
  public func detectPatterns(for patterns: Swift.Set<UIPasteboard.DetectionPattern>, inItemSet itemSet: Foundation.IndexSet?, completionHandler: @escaping (Swift.Result<[Swift.Set<UIPasteboard.DetectionPattern>], any Swift.Error>) -> ())
  @available(iOS 15.0, *)
  public func detectPatterns(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>, inItemSet itemSet: Foundation.IndexSet?, completionHandler: @escaping (Swift.Result<[Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>], any Swift.Error>) -> ())
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  public func detectedPatterns(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>, inItemSet itemSet: Foundation.IndexSet?) async throws -> [Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>]
  #endif
  @available(iOS, introduced: 14.0, deprecated: 15.0)
  @available(visionOS, introduced: 1.0, deprecated: 1.0)
  public func detectValues(for patterns: Swift.Set<UIPasteboard.DetectionPattern>, completionHandler: @escaping (Swift.Result<[UIPasteboard.DetectionPattern : Any], any Swift.Error>) -> ())
  @available(iOS 15.0, *)
  public func detectValues(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>, completionHandler: @escaping (Swift.Result<UIPasteboard.DetectedValues, any Swift.Error>) -> ())
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  public func detectedValues(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>) async throws -> UIPasteboard.DetectedValues
  #endif
  @available(iOS, introduced: 14.0, deprecated: 15.0)
  @available(visionOS, introduced: 1.0, deprecated: 1.0)
  public func detectValues(for patterns: Swift.Set<UIPasteboard.DetectionPattern>, inItemSet itemSet: Foundation.IndexSet?, completionHandler: @escaping (Swift.Result<[[UIPasteboard.DetectionPattern : Any]], any Swift.Error>) -> ())
  @available(iOS 15.0, *)
  public func detectValues(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>, inItemSet itemSet: Foundation.IndexSet?, completionHandler: @escaping (Swift.Result<[UIPasteboard.DetectedValues], any Swift.Error>) -> ())
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  public func detectedValues(for keyPaths: Swift.Set<Swift.PartialKeyPath<UIPasteboard.DetectedValues>>, inItemSet itemSet: Foundation.IndexSet?) async throws -> [UIPasteboard.DetectedValues]
  #endif
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewDiffableDataSource {
  @preconcurrency public struct SectionSnapshotHandlers<ItemIdentifierType> where ItemIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Sendable {
    public var shouldExpandItem: ((ItemIdentifierType) -> Swift.Bool)? {
      get
      set(handler)
    }
    public var willExpandItem: ((ItemIdentifierType) -> Swift.Void)? {
      get
      set(handler)
    }
    public var shouldCollapseItem: ((ItemIdentifierType) -> Swift.Bool)? {
      get
      set(handler)
    }
    public var willCollapseItem: ((ItemIdentifierType) -> Swift.Void)? {
      get
      set(handler)
    }
    public var snapshotForExpandingParent: ((ItemIdentifierType, UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)? {
      get
      set(handler)
    }
    public init()
  }
  @_Concurrency.MainActor(unsafe) public var sectionSnapshotHandlers: UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SectionSnapshotHandlers<ItemIdentifierType> {
    get
    set(handlers)
  }
}
@available(*, unavailable)
extension UIKit.UICollectionViewDiffableDataSource.SectionSnapshotHandlers : Swift.Sendable {
}
@available(iOS 17.0, tvOS 17.0, watchOS 10.0, *)
public struct UIImageReader {
  public struct Configuration : Swift.Equatable {
    public var prefersHighDynamicRange: Swift.Bool {
      get
      set
    }
    public var preparesImagesForDisplay: Swift.Bool {
      get
      set
    }
    public var preferredThumbnailSize: CoreFoundation.CGSize {
      get
      set
    }
    public var pixelsPerInch: Swift.Double {
      get
      set
    }
    public init()
    public static func == (a: UIKit.UIImageReader.Configuration, b: UIKit.UIImageReader.Configuration) -> Swift.Bool
  }
  public static let `default`: UIKit.UIImageReader
  public init(configuration: UIKit.UIImageReader.Configuration)
  public var configuration: UIKit.UIImageReader.Configuration {
    get
  }
  public func image(contentsOf fileURL: Foundation.URL) -> UIImage?
  public func image(data: Foundation.Data) -> UIImage?
  #if compiler(>=5.3) && $AsyncAwait
  public func image(contentsOf fileURL: Foundation.URL) async -> UIImage?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func image(data: Foundation.Data) async -> UIImage?
  #endif
}
extension UIBarButtonItem {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(systemItem: UIBarButtonItem.SystemItem, primaryAction: UIAction? = nil, menu: UIMenu? = nil)
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String? = nil, image: UIImage? = nil, primaryAction: UIAction? = nil, menu: UIMenu? = nil)
  @available(iOS 16.0, tvOS 16.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String?, image: UIImage?, target: Swift.AnyObject?, action: ObjectiveC.Selector?, menu: UIMenu? = nil)
}
extension UIBarButtonItem {
  @available(iOS 16.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @_Concurrency.MainActor(unsafe) public func creatingOptionalGroup(customizationIdentifier: Swift.String, isInDefaultCustomization: Swift.Bool = true) -> UIBarButtonItemGroup
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIBarButtonItem {
  @_Concurrency.MainActor(unsafe) public func addSymbolEffect(_ effect: some Symbols.SymbolEffect & Symbols.DiscreteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func addSymbolEffect(_ effect: some Symbols.SymbolEffect & Symbols.IndefiniteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func addSymbolEffect(_ effect: some Symbols.SymbolEffect & Symbols.DiscreteSymbolEffect & Symbols.IndefiniteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func removeSymbolEffect(ofType effect: some Symbols.SymbolEffect & Symbols.DiscreteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func removeSymbolEffect(ofType effect: some Symbols.SymbolEffect & Symbols.IndefiniteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func removeSymbolEffect(ofType effect: some Symbols.SymbolEffect & Symbols.DiscreteSymbolEffect & Symbols.IndefiniteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func removeAllSymbolEffects(options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func setSymbolImage(_ image: UIImage, contentTransition: some Symbols.SymbolEffect & Symbols.ContentTransitionSymbolEffect, options: Symbols.SymbolEffectOptions = .default)
}
@available(iOS 17.0, *)
public struct UIWindowSceneProminentPlacement : UIKit.UIWindowScenePlacement {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIWindowSceneProminentPlacement, b: UIKit.UIWindowSceneProminentPlacement) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 17.0, *)
extension UIKit.UIWindowScenePlacement where Self == UIKit.UIWindowSceneProminentPlacement {
  public static func prominent() -> Self
}
@available(iOS 14.5, *)
@available(tvOS, unavailable)
public struct UIListSeparatorConfiguration : Swift.Hashable {
  public enum Visibility : Swift.Hashable {
    case automatic
    case visible
    case hidden
    public static func == (a: UIKit.UIListSeparatorConfiguration.Visibility, b: UIKit.UIListSeparatorConfiguration.Visibility) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var topSeparatorVisibility: UIKit.UIListSeparatorConfiguration.Visibility {
    get
    set
  }
  public var bottomSeparatorVisibility: UIKit.UIListSeparatorConfiguration.Visibility {
    get
    set
  }
  public static let automaticInsets: NSDirectionalEdgeInsets
  public var topSeparatorInsets: NSDirectionalEdgeInsets {
    get
    set
  }
  public var bottomSeparatorInsets: NSDirectionalEdgeInsets {
    get
    set
  }
  public var color: UIColor {
    get
    set
  }
  public var multipleSelectionColor: UIColor {
    get
    set
  }
  @available(iOS 15.0, *)
  @available(tvOS, unavailable)
  public var visualEffect: UIVisualEffect? {
    get
    set(visualEffect)
  }
  public init(listAppearance: UIKit.UICollectionLayoutListConfiguration.Appearance)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIListSeparatorConfiguration, b: UIKit.UIListSeparatorConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.5, *)
@available(tvOS, unavailable)
extension UIKit.UIListSeparatorConfiguration : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.5, *)
@available(tvOS, unavailable)
extension UIKit.UIListSeparatorConfiguration : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> __UIListSeparatorConfiguration
  public static func _forceBridgeFromObjectiveC(_ source: __UIListSeparatorConfiguration, result: inout UIKit.UIListSeparatorConfiguration?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: __UIListSeparatorConfiguration, result: inout UIKit.UIListSeparatorConfiguration?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _configuration: __UIListSeparatorConfiguration?) -> UIKit.UIListSeparatorConfiguration
  public typealias _ObjectiveCType = __UIListSeparatorConfiguration
}
@available(iOS 13.4, *)
public enum UIPointerShape {
  case path(_: UIBezierPath)
  case roundedRect(_: CoreFoundation.CGRect, radius: CoreFoundation.CGFloat = UIPointerShape.defaultCornerRadius)
  case verticalBeam(length: CoreFoundation.CGFloat)
  case horizontalBeam(length: CoreFoundation.CGFloat)
  public static let defaultCornerRadius: CoreFoundation.CGFloat
}
@available(*, unavailable)
extension UIKit.UIPointerShape : Swift.Sendable {
}
@available(iOS 13.4, *)
public enum UIPointerEffect : Swift.Sendable, Swift.Equatable {
  public enum TintMode : Swift.Sendable, Swift.Equatable {
    case none, overlay, underlay
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIPointerEffect.TintMode, b: UIKit.UIPointerEffect.TintMode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  case automatic(_: UITargetedPreview)
  case highlight(_: UITargetedPreview)
  case lift(_: UITargetedPreview)
  case hover(_: UITargetedPreview, preferredTintMode: UIKit.UIPointerEffect.TintMode = .overlay, prefersShadow: Swift.Bool = false, prefersScaledContent: Swift.Bool = true)
  public var preview: UITargetedPreview {
    get
  }
  public static func == (a: UIKit.UIPointerEffect, b: UIKit.UIPointerEffect) -> Swift.Bool
}
@available(iOS 15.0, *)
extension UIPointerAccessory {
  public struct Position : Swift.Sendable {
    public static let defaultOffset: CoreFoundation.CGFloat
    public var offset: CoreFoundation.CGFloat
    public var angle: CoreFoundation.CGFloat
    public init(offset: CoreFoundation.CGFloat = Position.defaultOffset, angle: CoreFoundation.CGFloat = 0)
    public static var top: UIPointerAccessory.Position {
      get
    }
    public static var topRight: UIPointerAccessory.Position {
      get
    }
    public static var right: UIPointerAccessory.Position {
      get
    }
    public static var bottomRight: UIPointerAccessory.Position {
      get
    }
    public static var bottom: UIPointerAccessory.Position {
      get
    }
    public static var bottomLeft: UIPointerAccessory.Position {
      get
    }
    public static var left: UIPointerAccessory.Position {
      get
    }
    public static var topLeft: UIPointerAccessory.Position {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) convenience public init(_ shape: UIKit.UIPointerShape, position: UIPointerAccessory.Position)
  @_Concurrency.MainActor(unsafe) public class func arrow(_ position: UIPointerAccessory.Position) -> Self
  @_Concurrency.MainActor(unsafe) public var shape: UIKit.UIPointerShape {
    get
  }
}
@available(iOS 13.4, *)
extension UIPointerStyle {
  @_Concurrency.MainActor(unsafe) convenience public init(effect: UIKit.UIPointerEffect, shape: UIKit.UIPointerShape? = nil)
  @_Concurrency.MainActor(unsafe) convenience public init(shape: UIKit.UIPointerShape, constrainedAxes: UIAxis = [])
}
@available(iOS 13.4, *)
extension UIPointerRegion {
  @_Concurrency.MainActor(unsafe) convenience public init(rect: CoreFoundation.CGRect, identifier: Swift.AnyHashable? = nil)
  @_Concurrency.MainActor(unsafe) public var identifier: Swift.AnyHashable? {
    get
  }
}
@available(iOS 13.4, *)
extension UIButton {
  public typealias PointerStyleProvider = (_ button: UIButton, _ proposedEffect: UIKit.UIPointerEffect, _ proposedShape: UIKit.UIPointerShape) -> UIPointerStyle?
  @_Concurrency.MainActor(unsafe) public var pointerStyleProvider: UIButton.PointerStyleProvider? {
    get
    set
  }
}
@available(iOS 13.4, *)
extension UIKit.UIPointerEffect : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> __UIPointerEffect
  public static func _forceBridgeFromObjectiveC(_ input: __UIPointerEffect, result: inout UIKit.UIPointerEffect?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: __UIPointerEffect, result: inout UIKit.UIPointerEffect?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ internalEffect: __UIPointerEffect?) -> UIKit.UIPointerEffect
  public typealias _ObjectiveCType = __UIPointerEffect
}
@available(iOS 13.4, *)
extension UIKit.UIPointerShape : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> __UIPointerShape
  public static func _forceBridgeFromObjectiveC(_ input: __UIPointerShape, result: inout UIKit.UIPointerShape?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: __UIPointerShape, result: inout UIKit.UIPointerShape?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _effect: __UIPointerShape?) -> UIKit.UIPointerShape
  public typealias _ObjectiveCType = __UIPointerShape
}
@available(iOS 15.0, *)
extension UIBandSelectionInteraction {
  @_Concurrency.MainActor(unsafe) public var selectionRect: CoreFoundation.CGRect? {
    get
  }
}
@available(iOS 15.0, *)
@available(tvOS, unavailable)
extension UIToolTipConfiguration {
  public var sourceRect: CoreFoundation.CGRect? {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
@preconcurrency public struct NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> : @unchecked Swift.Sendable where ItemIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Sendable {
  public init()
  public init(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)
  public mutating func append(_ items: [ItemIdentifierType], to parent: ItemIdentifierType? = nil)
  public mutating func insert(_ items: [ItemIdentifierType], before item: ItemIdentifierType)
  public mutating func insert(_ items: [ItemIdentifierType], after item: ItemIdentifierType)
  public mutating func delete(_ items: [ItemIdentifierType])
  public mutating func deleteAll()
  public mutating func expand(_ items: [ItemIdentifierType])
  public mutating func collapse(_ items: [ItemIdentifierType])
  public mutating func replace(childrenOf parent: ItemIdentifierType, using snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)
  public mutating func insert(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, before item: (ItemIdentifierType))
  public mutating func insert(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, after item: (ItemIdentifierType))
  public func isExpanded(_ item: ItemIdentifierType) -> Swift.Bool
  public func isVisible(_ item: ItemIdentifierType) -> Swift.Bool
  public func contains(_ item: ItemIdentifierType) -> Swift.Bool
  public func level(of item: ItemIdentifierType) -> Swift.Int
  public func index(of item: ItemIdentifierType) -> Swift.Int?
  public func parent(of child: ItemIdentifierType) -> ItemIdentifierType?
  public func snapshot(of parent: ItemIdentifierType, includingParent: Swift.Bool = false) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
  public var items: [ItemIdentifierType] {
    get
  }
  public var rootItems: [ItemIdentifierType] {
    get
  }
  public var visibleItems: [ItemIdentifierType] {
    get
  }
  public func visualDescription() -> Swift.String
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewDiffableDataSource {
  nonisolated public func apply(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, to section: SectionIdentifierType, animatingDifferences: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated public func apply(_ snapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, to section: SectionIdentifierType, animatingDifferences: Swift.Bool = true) async
  #endif
  nonisolated public func snapshot(for section: SectionIdentifierType) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.NSDiffableDataSourceSectionSnapshot : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSDiffableDataSourceSectionSnapshotReference
  public static func _forceBridgeFromObjectiveC(_ input: NSDiffableDataSourceSectionSnapshotReference, result: inout UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: NSDiffableDataSourceSectionSnapshotReference, result: inout UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ snapshot: NSDiffableDataSourceSectionSnapshotReference?) -> UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
  public typealias _ObjectiveCType = NSDiffableDataSourceSectionSnapshotReference
}
extension UIBarButtonItemGroup {
  @available(iOS 16.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @_Concurrency.MainActor(unsafe) public class func fixedGroup(representativeItem: UIBarButtonItem? = nil, items: [UIBarButtonItem]) -> UIBarButtonItemGroup
  @available(iOS 16.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @_Concurrency.MainActor(unsafe) public class func movableGroup(customizationIdentifier: Swift.String, representativeItem: UIBarButtonItem? = nil, items: [UIBarButtonItem]) -> UIBarButtonItemGroup
  @available(iOS 16.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @_Concurrency.MainActor(unsafe) public class func optionalGroup(customizationIdentifier: Swift.String, isInDefaultCustomization: Swift.Bool = true, representativeItem: UIBarButtonItem? = nil, items: [UIBarButtonItem]) -> UIBarButtonItemGroup
}
@available(iOS 14.0, tvOS 14.0, *)
@preconcurrency public struct NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType> : @unchecked Swift.Sendable where SectionIdentifierType : Swift.Hashable, SectionIdentifierType : Swift.Sendable, ItemIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Sendable {
  public var sectionIdentifier: SectionIdentifierType {
    get
  }
  public var initialSnapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> {
    get
  }
  public var finalSnapshot: UIKit.NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> {
    get
  }
  public var difference: Swift.CollectionDifference<ItemIdentifierType> {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
@preconcurrency public struct NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType> : @unchecked Swift.Sendable where SectionIdentifierType : Swift.Hashable, SectionIdentifierType : Swift.Sendable, ItemIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Sendable {
  public var initialSnapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> {
    get
  }
  public var finalSnapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> {
    get
  }
  public var difference: Swift.CollectionDifference<ItemIdentifierType> {
    get
  }
  public var sectionTransactions: [UIKit.NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType>] {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionViewDiffableDataSource {
  public struct ReorderingHandlers {
    public var canReorderItem: ((ItemIdentifierType) -> Swift.Bool)? {
      get
      set(handler)
    }
    public var willReorder: ((UIKit.NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>) -> Swift.Void)? {
      get
      set(handler)
    }
    public var didReorder: ((UIKit.NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>) -> Swift.Void)? {
      get
      set(handler)
    }
    public init()
  }
  @_Concurrency.MainActor(unsafe) public var reorderingHandlers: UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.ReorderingHandlers {
    get
    set(handlers)
  }
}
@available(*, unavailable)
extension UIKit.UICollectionViewDiffableDataSource.ReorderingHandlers : Swift.Sendable {
}
extension UIViewController {
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) public func setContentScrollView(_ scrollView: UIScrollView?)
}
@available(iOS 11.0, tvOS 11.0, *)
extension UIContentSizeCategory {
  public var isAccessibilityCategory: Swift.Bool {
    get
  }
  public static func < (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Swift.Bool
  public static func <= (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Swift.Bool
  public static func > (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Swift.Bool
  public static func >= (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Swift.Bool
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIContentSizeCategory : Swift.Comparable {
}
@available(iOS 16.0, *)
public struct UITextSearchAggregator<DocumentIdentifier> where DocumentIdentifier : Swift.Hashable {
  public var allFoundRanges: [UITextRange] {
    get
  }
  public func foundRange(_ range: UITextRange, searchString: Swift.String, document: DocumentIdentifier)
  public func invalidateFoundRange(_ range: UITextRange, document: DocumentIdentifier)
  public func invalidate()
  public func finishedSearching()
}
@available(iOS 16.0, *)
public protocol UITextSearching : ObjectiveC.NSObjectProtocol {
  associatedtype DocumentIdentifier : Swift.Hashable = Swift.AnyHashable?
  var selectedTextRange: UITextRange? { get }
  func compare(_ foundRange: UITextRange, toRange: UITextRange, document: Self.DocumentIdentifier?) -> Foundation.ComparisonResult
  func performTextSearch(queryString: Swift.String, options: UITextSearchOptions, resultAggregator: UIKit.UITextSearchAggregator<Self.DocumentIdentifier>)
  func decorate(foundTextRange: UITextRange, document: Self.DocumentIdentifier?, usingStyle: UITextSearchFoundTextStyle)
  func clearAllDecoratedFoundText()
  var supportsTextReplacement: Swift.Bool { get }
  func shouldReplace(foundTextRange: UITextRange, document: Self.DocumentIdentifier?, withText: Swift.String) -> Swift.Bool
  func replace(foundTextRange: UITextRange, document: Self.DocumentIdentifier?, withText: Swift.String)
  func replaceAll(queryString: Swift.String, options: UITextSearchOptions, withText: Swift.String)
  func willHighlight(foundTextRange: UITextRange, document: Self.DocumentIdentifier?)
  func scrollRangeToVisible(_ range: UITextRange, inDocument: Self.DocumentIdentifier?)
  var selectedTextSearchDocument: Self.DocumentIdentifier? { get }
  func compare(document: Self.DocumentIdentifier, toDocument: Self.DocumentIdentifier) -> Foundation.ComparisonResult
}
extension UIKit.UITextSearching {
  public var supportsTextReplacement: Swift.Bool {
    get
  }
  public func shouldReplace(foundTextRange: UITextRange, document: Self.DocumentIdentifier?, withText: Swift.String) -> Swift.Bool
  public func replace(foundTextRange: UITextRange, document: Self.DocumentIdentifier?, withText: Swift.String)
  public func replaceAll(queryString: Swift.String, options: UITextSearchOptions, withText: Swift.String)
  public func willHighlight(foundTextRange: UITextRange, document: Self.DocumentIdentifier?)
  public func scrollRangeToVisible(_ range: UITextRange, inDocument: Self.DocumentIdentifier?)
  public var selectedTextSearchDocument: Self.DocumentIdentifier? {
    get
  }
  public func compare(document: Self.DocumentIdentifier, toDocument: Self.DocumentIdentifier) -> Foundation.ComparisonResult
}
extension UITextSearchingFindSession {
  @_Concurrency.MainActor(unsafe) convenience public init<SearchableObject>(searchableObject: SearchableObject) where SearchableObject : UIKit.UITextSearching
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol UIHoverEffect {
  func _resolve(in context: UIKit._UIHoverEffectResolutionContext) -> UIKit._UIResolvedHoverEffect
  func _makeBridgedEffect() -> any __UIHoverEffect
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct _UIHoverEffectResolutionContext {
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct _UIResolvedHoverEffect : UIKit.UIHoverEffect {
  public func _resolve(in context: UIKit._UIHoverEffectResolutionContext) -> UIKit._UIResolvedHoverEffect
  public func _makeBridgedEffect() -> any __UIHoverEffect
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct UIHoverHighlightEffect : UIKit.UIHoverEffect {
  public init()
  public func _resolve(in context: UIKit._UIHoverEffectResolutionContext) -> UIKit._UIResolvedHoverEffect
  public func _makeBridgedEffect() -> any __UIHoverEffect
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension UIKit.UIHoverEffect where Self == UIKit.UIHoverHighlightEffect {
  public static var highlight: UIKit.UIHoverHighlightEffect {
    get
  }
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct UIHoverLiftEffect : UIKit.UIHoverEffect {
  public init()
  public func _resolve(in context: UIKit._UIHoverEffectResolutionContext) -> UIKit._UIResolvedHoverEffect
  public func _makeBridgedEffect() -> any __UIHoverEffect
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension UIKit.UIHoverEffect where Self == UIKit.UIHoverLiftEffect {
  public static var lift: UIKit.UIHoverLiftEffect {
    get
  }
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct UIHoverAutomaticEffect : UIKit.UIHoverEffect {
  public init()
  public func _resolve(in context: UIKit._UIHoverEffectResolutionContext) -> UIKit._UIResolvedHoverEffect
  public func _makeBridgedEffect() -> any __UIHoverEffect
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension UIKit.UIHoverEffect where Self == UIKit.UIHoverAutomaticEffect {
  public static var automatic: UIKit.UIHoverAutomaticEffect {
    get
  }
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension UIKit.UIPointerEffect : UIKit.UIHoverEffect {
  public func _resolve(in context: UIKit._UIHoverEffectResolutionContext) -> UIKit._UIResolvedHoverEffect
  public func _makeBridgedEffect() -> any __UIHoverEffect
}
@available(*, unavailable)
extension UIKit.UIHoverHighlightEffect : Swift.Sendable {
}
@available(*, unavailable)
extension UIKit.UIHoverLiftEffect : Swift.Sendable {
}
@available(*, unavailable)
extension UIKit.UIHoverAutomaticEffect : Swift.Sendable {
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
extension DeveloperToolsSupport.Preview {
  public init(_ name: Swift.String? = nil, traits: DeveloperToolsSupport.PreviewTrait<DeveloperToolsSupport.Preview.ViewTraits>..., body: @escaping @_Concurrency.MainActor () -> UIView)
  public init(_ name: Swift.String? = nil, traits: DeveloperToolsSupport.PreviewTrait<DeveloperToolsSupport.Preview.ViewTraits>..., body: @escaping @_Concurrency.MainActor () -> UIViewController)
}
#if compiler(>=5.3) && $Macros && $FreestandingMacros
@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@freestanding(declaration) public macro Preview(_ name: Swift.String? = nil, traits: DeveloperToolsSupport.PreviewTrait<DeveloperToolsSupport.Preview.ViewTraits>..., body: @escaping @_Concurrency.MainActor () -> UIView) = #externalMacro(module: "PreviewsMacros", type: "Common")
#endif
#if compiler(>=5.3) && $Macros && $FreestandingMacros
@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@freestanding(declaration) public macro Preview(_ name: Swift.String? = nil, traits: DeveloperToolsSupport.PreviewTrait<DeveloperToolsSupport.Preview.ViewTraits>..., body: @escaping @_Concurrency.MainActor () -> UIViewController) = #externalMacro(module: "PreviewsMacros", type: "Common")
#endif
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
public protocol UIViewInvalidating {
  func invalidate(view: UIView)
}
extension UIView {
  @available(swift 5.1)
  @available(iOS 15, tvOS 15, *)
  @propertyWrapper public struct Invalidating<Value, InvalidationType> where Value : Swift.Equatable, InvalidationType : UIKit.UIViewInvalidating {
    @available(*, unavailable, message: "@UIView.Invalidating can only be used on subclasses of UIView")
    public var wrappedValue: Value {
      get
      set
    }
    public init(wrappedValue: Value, _ invalidation: InvalidationType)
    public init<InvalidationType1, InvalidationType2>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2) where InvalidationType == UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, InvalidationType3>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, InvalidationType5>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating, InvalidationType6 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, InvalidationType7>>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating, InvalidationType6 : UIKit.UIViewInvalidating, InvalidationType7 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, UIView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating, InvalidationType6 : UIKit.UIViewInvalidating, InvalidationType7 : UIKit.UIViewInvalidating, InvalidationType8 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8, InvalidationType9>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8, _ invalidation9: InvalidationType9) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, UIView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, InvalidationType9>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating, InvalidationType6 : UIKit.UIViewInvalidating, InvalidationType7 : UIKit.UIViewInvalidating, InvalidationType8 : UIKit.UIViewInvalidating, InvalidationType9 : UIKit.UIViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8, InvalidationType9, InvalidationType10>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8, _ invalidation9: InvalidationType9, _ invalidation10: InvalidationType10) where InvalidationType == UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, UIView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, UIView.Invalidations.Tuple<UIView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, UIView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, UIView.Invalidations.Tuple<InvalidationType9, InvalidationType10>>, InvalidationType1 : UIKit.UIViewInvalidating, InvalidationType2 : UIKit.UIViewInvalidating, InvalidationType3 : UIKit.UIViewInvalidating, InvalidationType4 : UIKit.UIViewInvalidating, InvalidationType5 : UIKit.UIViewInvalidating, InvalidationType6 : UIKit.UIViewInvalidating, InvalidationType7 : UIKit.UIViewInvalidating, InvalidationType8 : UIKit.UIViewInvalidating, InvalidationType9 : UIKit.UIViewInvalidating, InvalidationType10 : UIKit.UIViewInvalidating
    public static subscript<EnclosingSelf>(_enclosingInstance observed: EnclosingSelf, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, UIView.Invalidating<Value, InvalidationType>>) -> Value where EnclosingSelf : UIView {
      get
      set
    }
  }
}
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIKit.UIViewInvalidating where Self == UIView.Invalidations.Display {
  @_alwaysEmitIntoClient public static var display: UIView.Invalidations.Display {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIKit.UIViewInvalidating where Self == UIView.Invalidations.Layout {
  @_alwaysEmitIntoClient public static var layout: UIView.Invalidations.Layout {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIKit.UIViewInvalidating where Self == UIView.Invalidations.Constraints {
  @_alwaysEmitIntoClient public static var constraints: UIView.Invalidations.Constraints {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIKit.UIViewInvalidating where Self == UIView.Invalidations.IntrinsicContentSize {
  @_alwaysEmitIntoClient public static var intrinsicContentSize: UIView.Invalidations.IntrinsicContentSize {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(iOS 15, tvOS 15, *)
extension UIKit.UIViewInvalidating where Self == UIView.Invalidations.Configuration {
  @_alwaysEmitIntoClient public static var configuration: UIView.Invalidations.Configuration {
    get { return .init() }
  }
}
extension UIView {
  @available(swift 5.1)
  @available(iOS 15, tvOS 15, *)
  public enum Invalidations {
    public struct Display : UIKit.UIViewInvalidating {
      public init()
      public func invalidate(view: UIView)
    }
    public struct Layout : UIKit.UIViewInvalidating {
      public init()
      public func invalidate(view: UIView)
    }
    public struct Constraints : UIKit.UIViewInvalidating {
      public init()
      public func invalidate(view: UIView)
    }
    public struct IntrinsicContentSize : UIKit.UIViewInvalidating {
      public init()
      public func invalidate(view: UIView)
    }
    public struct Configuration : UIKit.UIViewInvalidating {
      public init()
      public func invalidate(view: UIView)
    }
    public struct Tuple<Invalidation1, Invalidation2> : UIKit.UIViewInvalidating where Invalidation1 : UIKit.UIViewInvalidating, Invalidation2 : UIKit.UIViewInvalidating {
      public init(_ invalidation1: Invalidation1, _ invalidation2: Invalidation2)
      public func invalidate(view: UIView)
    }
  }
}
@available(*, unavailable)
extension UIView.Invalidating : Swift.Sendable {
}
@available(*, unavailable)
extension UIView.Invalidations : Swift.Sendable {
}
@available(*, unavailable)
extension UIView.Invalidations.Display : Swift.Sendable {
}
@available(*, unavailable)
extension UIView.Invalidations.Layout : Swift.Sendable {
}
@available(*, unavailable)
extension UIView.Invalidations.Constraints : Swift.Sendable {
}
@available(*, unavailable)
extension UIView.Invalidations.IntrinsicContentSize : Swift.Sendable {
}
@available(*, unavailable)
extension UIView.Invalidations.Configuration : Swift.Sendable {
}
@available(*, unavailable)
extension UIView.Invalidations.Tuple : Swift.Sendable {
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIViewController {
  @available(iOS 17.0, tvOS 17.0, *)
  @_Concurrency.MainActor(unsafe) public var contentUnavailableConfiguration: (any UIKit.UIContentConfiguration)? {
    get
    set(config)
  }
  @available(iOS 17.0, tvOS 17.0, *)
  @objc(_bridgedContentUnavailableConfigurationState) @_Concurrency.MainActor(unsafe) dynamic open var contentUnavailableConfigurationState: UIKit.UIContentUnavailableConfigurationState {
    @objc get
  }
  @available(iOS 17.0, tvOS 17.0, *)
  @objc(_bridgedUpdateContentUnavailableConfigurationUsingState:) @_Concurrency.MainActor(unsafe) dynamic open func updateContentUnavailableConfiguration(using state: UIKit.UIContentUnavailableConfigurationState)
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIContentUnavailableView : UIKit.UIContentView {
  @available(iOS 17.0, tvOS 17.0, *)
  @_Concurrency.MainActor public func supports(_ configuration: any UIKit.UIContentConfiguration) -> Swift.Bool
  @available(iOS 17.0, tvOS 17.0, *)
  @_Concurrency.MainActor public var configuration: any UIKit.UIContentConfiguration {
    get
    set(config)
  }
  @available(iOS 17.0, tvOS 17.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(configuration: UIKit.UIContentUnavailableConfiguration)
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UIContentUnavailableConfiguration : UIKit.UIContentConfiguration, Swift.Hashable {
  public struct ImageProperties : Swift.Hashable {
    public var preferredSymbolConfiguration: UIImage.SymbolConfiguration? {
      get
      set(preferredSymbolConfiguration)
    }
    public var tintColor: UIColor? {
      get
      set(tintColor)
    }
    public var cornerRadius: CoreFoundation.CGFloat {
      get
      set(cornerRadius)
    }
    public var maximumSize: CoreFoundation.CGSize {
      get
      set(maximumSize)
    }
    public var accessibilityIgnoresInvertColors: Swift.Bool {
      get
      set(accessibilityIgnoresInvertColors)
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIContentUnavailableConfiguration.ImageProperties, b: UIKit.UIContentUnavailableConfiguration.ImageProperties) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct TextProperties : Swift.Hashable {
    public var font: UIFont {
      get
      set(font)
    }
    public var color: UIColor {
      get
      set(color)
    }
    public var lineBreakMode: NSLineBreakMode {
      get
      set(lineBreakMode)
    }
    public var numberOfLines: Swift.Int {
      get
      set(numberOfLines)
    }
    public var adjustsFontSizeToFitWidth: Swift.Bool {
      get
      set(adjustsFontSizeToFitWidth)
    }
    public var minimumScaleFactor: CoreFoundation.CGFloat {
      get
      set(minimumScaleFactor)
    }
    public var allowsDefaultTighteningForTruncation: Swift.Bool {
      get
      set(allowsDefaultTighteningForTruncation)
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIContentUnavailableConfiguration.TextProperties, b: UIKit.UIContentUnavailableConfiguration.TextProperties) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct ButtonProperties : Swift.Hashable {
    public var primaryAction: UIAction? {
      get
      set(primaryAction)
    }
    public var menu: UIMenu? {
      get
      set(menu)
    }
    public var isEnabled: Swift.Bool {
      get
      set(enabled)
    }
    public var role: UIButton.Role {
      get
      set(role)
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: UIKit.UIContentUnavailableConfiguration.ButtonProperties, b: UIKit.UIContentUnavailableConfiguration.ButtonProperties) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Alignment : Swift.Hashable {
    case natural
    case center
    public static func == (a: UIKit.UIContentUnavailableConfiguration.Alignment, b: UIKit.UIContentUnavailableConfiguration.Alignment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func empty() -> UIKit.UIContentUnavailableConfiguration
  public static func loading() -> UIKit.UIContentUnavailableConfiguration
  public static func search() -> UIKit.UIContentUnavailableConfiguration
  @_Concurrency.MainActor public func makeContentView() -> any UIView & UIKit.UIContentView
  public func updated(for state: any UIKit.UIConfigurationState) -> UIKit.UIContentUnavailableConfiguration
  public var image: UIImage? {
    get
    set(image)
  }
  public var imageProperties: UIKit.UIContentUnavailableConfiguration.ImageProperties {
    get
    set(imageProperties)
  }
  public var text: Swift.String? {
    get
    set(text)
  }
  public var attributedText: Foundation.NSAttributedString? {
    get
    set(attributedText)
  }
  public var textProperties: UIKit.UIContentUnavailableConfiguration.TextProperties {
    get
    set(textProperties)
  }
  public var secondaryText: Swift.String? {
    get
    set(secondaryText)
  }
  public var secondaryAttributedText: Foundation.NSAttributedString? {
    get
    set(secondaryAttributedText)
  }
  public var secondaryTextProperties: UIKit.UIContentUnavailableConfiguration.TextProperties {
    get
    set(secondaryTextProperties)
  }
  public var button: UIButton.Configuration {
    get
    set(button)
  }
  public var buttonProperties: UIKit.UIContentUnavailableConfiguration.ButtonProperties {
    get
    set(buttonProperties)
  }
  public var secondaryButton: UIButton.Configuration {
    get
    set(secondaryButton)
  }
  public var secondaryButtonProperties: UIKit.UIContentUnavailableConfiguration.ButtonProperties {
    get
    set(secondaryButtonProperties)
  }
  public var alignment: UIKit.UIContentUnavailableConfiguration.Alignment {
    get
    set(alignment)
  }
  public var axesPreservingSuperviewLayoutMargins: UIAxis {
    get
    set(axesPreservingSuperviewLayoutMargins)
  }
  public var directionalLayoutMargins: NSDirectionalEdgeInsets {
    get
    set(directionalLayoutMargins)
  }
  public var imageToTextPadding: CoreFoundation.CGFloat {
    get
    set(imageToTextPadding)
  }
  public var textToSecondaryTextPadding: CoreFoundation.CGFloat {
    get
    set(textToSecondaryTextPadding)
  }
  public var textToButtonPadding: CoreFoundation.CGFloat {
    get
    set(textToButtonPadding)
  }
  public var buttonToSecondaryButtonPadding: CoreFoundation.CGFloat {
    get
    set(buttonToSecondaryButtonPadding)
  }
  public var background: UIKit.UIBackgroundConfiguration {
    get
    set(background)
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIContentUnavailableConfiguration, b: UIKit.UIContentUnavailableConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIContentUnavailableConfiguration.ImageProperties : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIContentUnavailableConfiguration.TextProperties : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIContentUnavailableConfiguration.ButtonProperties : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIContentUnavailableConfiguration : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UIContentUnavailableConfigurationState : UIKit.UIConfigurationState, Swift.Hashable {
  public var traitCollection: UITraitCollection {
    get
    set
  }
  public var searchText: Swift.String? {
    get
    set
  }
  public subscript(key: UIConfigurationStateCustomKey) -> Swift.AnyHashable? {
    get
    set
  }
  public init(traitCollection: UITraitCollection)
  public static func == (lhs: UIKit.UIContentUnavailableConfigurationState, rhs: UIKit.UIContentUnavailableConfigurationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIContentUnavailableConfigurationState : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> __UIContentUnavailableConfigurationState
  public static func _forceBridgeFromObjectiveC(_ input: __UIContentUnavailableConfigurationState, result: inout UIKit.UIContentUnavailableConfigurationState?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: __UIContentUnavailableConfigurationState, result: inout UIKit.UIContentUnavailableConfigurationState?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _state: __UIContentUnavailableConfigurationState?) -> UIKit.UIContentUnavailableConfigurationState
  public typealias _ObjectiveCType = __UIContentUnavailableConfigurationState
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIContentUnavailableConfigurationState : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 16.0, *)
@available(tvOS, unavailable)
extension UICalendarView.Decoration {
  @_Concurrency.MainActor(unsafe) public static func `default`(color: UIColor? = nil, size: UICalendarView.DecorationSize = .medium) -> UICalendarView.Decoration
  @_Concurrency.MainActor(unsafe) public static func image(_ image: UIImage?, color: UIColor? = nil, size: UICalendarView.DecorationSize = .medium) -> UICalendarView.Decoration
}
extension UIView {
  @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
  @_Concurrency.MainActor(unsafe) public class func animate(springDuration duration: Foundation.TimeInterval = 0.5, bounce: CoreFoundation.CGFloat = 0.0, initialSpringVelocity: CoreFoundation.CGFloat = 0.0, delay: Foundation.TimeInterval = 0.0, options: UIView.AnimationOptions = [], animations: () -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)? = nil)
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UICollectionLayoutListConfiguration {
  public enum Appearance {
    case plain
    case grouped
    @available(tvOS, unavailable)
    case insetGrouped
    @available(tvOS, unavailable)
    case sidebar
    @available(tvOS, unavailable)
    case sidebarPlain
    public static func == (a: UIKit.UICollectionLayoutListConfiguration.Appearance, b: UIKit.UICollectionLayoutListConfiguration.Appearance) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum HeaderMode {
    case none, supplementary, firstItemInSection
    public static func == (a: UIKit.UICollectionLayoutListConfiguration.HeaderMode, b: UIKit.UICollectionLayoutListConfiguration.HeaderMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum FooterMode {
    case none, supplementary
    public static func == (a: UIKit.UICollectionLayoutListConfiguration.FooterMode, b: UIKit.UICollectionLayoutListConfiguration.FooterMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(tvOS, unavailable)
  public typealias SwipeActionsConfigurationProvider = (_ indexPath: Foundation.IndexPath) -> UISwipeActionsConfiguration?
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  public typealias ItemSeparatorHandler = (_ itemIndexPath: Foundation.IndexPath, _ sectionSeparatorConfiguration: UIKit.UIListSeparatorConfiguration) -> UIKit.UIListSeparatorConfiguration
  public init(appearance: UIKit.UICollectionLayoutListConfiguration.Appearance)
  public var appearance: UIKit.UICollectionLayoutListConfiguration.Appearance {
    get
  }
  @available(tvOS, unavailable)
  public var showsSeparators: Swift.Bool {
    get
    set(showsSeparators)
  }
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  public var separatorConfiguration: UIKit.UIListSeparatorConfiguration {
    get
    set(separatorConfiguration)
  }
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  public var itemSeparatorHandler: UIKit.UICollectionLayoutListConfiguration.ItemSeparatorHandler? {
    get
    set
  }
  public var backgroundColor: UIColor? {
    get
    set(color)
  }
  @available(tvOS, unavailable)
  public var leadingSwipeActionsConfigurationProvider: UIKit.UICollectionLayoutListConfiguration.SwipeActionsConfigurationProvider? {
    get
    set(provider)
  }
  @available(tvOS, unavailable)
  public var trailingSwipeActionsConfigurationProvider: UIKit.UICollectionLayoutListConfiguration.SwipeActionsConfigurationProvider? {
    get
    set(provider)
  }
  public var headerMode: UIKit.UICollectionLayoutListConfiguration.HeaderMode {
    get
    set(mode)
  }
  public var footerMode: UIKit.UICollectionLayoutListConfiguration.FooterMode {
    get
    set(mode)
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var headerTopPadding: CoreFoundation.CGFloat? {
    get
    set
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCompositionalLayout {
  @_Concurrency.MainActor(unsafe) public static func list(using configuration: UIKit.UICollectionLayoutListConfiguration) -> UICollectionViewCompositionalLayout
}
@available(iOS 14.0, tvOS 14.0, *)
extension NSCollectionLayoutSection {
  @_Concurrency.MainActor(unsafe) public static func list(using configuration: UIKit.UICollectionLayoutListConfiguration, layoutEnvironment: any NSCollectionLayoutEnvironment) -> NSCollectionLayoutSection
}
@available(iOS 15.0, tvOS 15.0, *)
extension UIFocusSystem {
  @_Concurrency.MainActor(unsafe) public class func focusSystem(for environment: any UIFocusEnvironment) -> UIFocusSystem?
}
extension NSCollectionLayoutGroup {
  @available(iOS, introduced: 16.0, deprecated: 16.0, renamed: "horizontal(layoutSize:repeatingSubitem:count:)")
  @_Concurrency.MainActor(unsafe) public class func horizontalGroup(with size: NSCollectionLayoutSize, repeatingSubitem subitem: NSCollectionLayoutItem, count: Swift.Int) -> NSCollectionLayoutGroup
  @available(iOS, introduced: 16.0, deprecated: 16.0, renamed: "vertical(layoutSize:repeatingSubitem:count:)")
  @_Concurrency.MainActor(unsafe) public class func verticalGroup(with size: NSCollectionLayoutSize, repeatingSubitem subitem: NSCollectionLayoutItem, count: Swift.Int) -> NSCollectionLayoutGroup
}
extension UIApplication {
  @available(iOS 16.0, *)
  @_Concurrency.MainActor(unsafe) public static let openNotificationSettingsURLString: Swift.String
}
@available(iOS 17.0, *)
@available(tvOS, unavailable)
extension UIPopoverPresentationControllerSourceItem {
  public func frame(in referenceView: UIView) -> CoreFoundation.CGRect?
}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes {
  public var uiKit: Foundation.AttributeScopes.UIKitAttributes.Type {
    get
  }
  public struct UIKitAttributes : Foundation.AttributeScope {
    public let font: Foundation.AttributeScopes.UIKitAttributes.FontAttribute
    public let paragraphStyle: Foundation.AttributeScopes.UIKitAttributes.ParagraphStyleAttribute
    public let foregroundColor: Foundation.AttributeScopes.UIKitAttributes.ForegroundColorAttribute
    public let backgroundColor: Foundation.AttributeScopes.UIKitAttributes.BackgroundColorAttribute
    public let ligature: Foundation.AttributeScopes.UIKitAttributes.LigatureAttribute
    public let kern: Foundation.AttributeScopes.UIKitAttributes.KernAttribute
    public let tracking: Foundation.AttributeScopes.UIKitAttributes.TrackingAttribute
    public let strikethroughStyle: Foundation.AttributeScopes.UIKitAttributes.StrikethroughStyleAttribute
    public let underlineStyle: Foundation.AttributeScopes.UIKitAttributes.UnderlineStyleAttribute
    public let strokeColor: Foundation.AttributeScopes.UIKitAttributes.StrokeColorAttribute
    public let strokeWidth: Foundation.AttributeScopes.UIKitAttributes.StrokeWidthAttribute
    public let shadow: Foundation.AttributeScopes.UIKitAttributes.ShadowAttribute
    public let textEffect: Foundation.AttributeScopes.UIKitAttributes.TextEffectAttribute
    public let baselineOffset: Foundation.AttributeScopes.UIKitAttributes.BaselineOffsetAttribute
    public let underlineColor: Foundation.AttributeScopes.UIKitAttributes.UnderlineColorAttribute
    public let strikethroughColor: Foundation.AttributeScopes.UIKitAttributes.StrikethroughColorAttribute
    @available(iOS, introduced: 15.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
    public let obliqueness: Foundation.AttributeScopes.UIKitAttributes.ObliquenessAttribute
    @available(iOS, introduced: 15.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
    public let expansion: Foundation.AttributeScopes.UIKitAttributes.ExpansionAttribute
    @available(iOS 17.0, *)
    @available(tvOS, unavailable)
    public let textItemTag: Foundation.AttributeScopes.UIKitAttributes.TextItemTagAttribute
    public let attachment: Foundation.AttributeScopes.UIKitAttributes.AttachmentAttribute
    public let accessibility: Foundation.AttributeScopes.AccessibilityAttributes
    public let foundation: Foundation.AttributeScopes.FoundationAttributes
    public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
    public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  }
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes : Swift.Sendable {
}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeDynamicLookup {
  @_disfavoredOverload public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes.UIKitAttributes, T>) -> T where T : Foundation.AttributedStringKey {
    get
  }
}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension NSUnderlineStyle : Swift.Hashable {
}
@available(iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.UIKitAttributes {
  @frozen public enum FontAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIFont
    public static let name: Swift.String
  }
  @frozen public enum ParagraphStyleAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = NSParagraphStyle
    public static let name: Swift.String
  }
  @frozen public enum ForegroundColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIColor
    public static let name: Swift.String
  }
  @frozen public enum BackgroundColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIColor
    public static let name: Swift.String
  }
  @frozen public enum LigatureAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.Int
    public static let name: Swift.String
  }
  @frozen public enum KernAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum TrackingAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum StrikethroughStyleAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = NSUnderlineStyle
    public typealias ObjectiveCValue = Foundation.NSNumber
    public static let name: Swift.String
    public static func encode(_ value: NSUnderlineStyle, to encoder: any Swift.Encoder) throws
    public static func decode(from decoder: any Swift.Decoder) throws -> NSUnderlineStyle
  }
  @frozen public enum UnderlineStyleAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = NSUnderlineStyle
    public typealias ObjectiveCValue = Foundation.NSNumber
    public static let name: Swift.String
    public static func encode(_ value: NSUnderlineStyle, to encoder: any Swift.Encoder) throws
    public static func decode(from decoder: any Swift.Decoder) throws -> NSUnderlineStyle
  }
  @frozen public enum StrokeColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIColor
    public static let name: Swift.String
  }
  @frozen public enum StrokeWidthAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum ShadowAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = NSShadow
    public static let name: Swift.String
  }
  @frozen public enum TextEffectAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.NSAttributedString.TextEffectStyle
    public static let name: Swift.String
    public static func encode(_ value: Foundation.NSAttributedString.TextEffectStyle, to encoder: any Swift.Encoder) throws
    public static func decode(from decoder: any Swift.Decoder) throws -> Foundation.NSAttributedString.TextEffectStyle
  }
  @frozen public enum AttachmentAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = NSTextAttachment
    public static let name: Swift.String
  }
  @frozen public enum BaselineOffsetAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum UnderlineColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIColor
    public static let name: Swift.String
  }
  @frozen public enum StrikethroughColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = UIColor
    public static let name: Swift.String
  }
  @available(iOS, introduced: 15.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
  @frozen public enum ObliquenessAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @available(iOS, introduced: 15.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
  @frozen public enum ExpansionAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @available(iOS 17.0, *)
  @available(tvOS, unavailable)
  @frozen public enum TextItemTagAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.String
    public static let name: Swift.String
  }
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.FontAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.ParagraphStyleAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.ForegroundColorAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.BackgroundColorAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.LigatureAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.KernAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.TrackingAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.StrikethroughStyleAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.UnderlineStyleAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.StrokeColorAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.StrokeWidthAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.ShadowAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.TextEffectAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.AttachmentAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.BaselineOffsetAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.UnderlineColorAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.StrikethroughColorAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.ObliquenessAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.ExpansionAttribute : Swift.Sendable {
}
@available(*, unavailable)
extension Foundation.AttributeScopes.UIKitAttributes.TextItemTagAttribute : Swift.Sendable {
}
@available(iOS 17.0, tvOS 17.0, *)
public struct UIWindowSceneStandardPlacement : UIKit.UIWindowScenePlacement {
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIWindowSceneStandardPlacement, b: UIKit.UIWindowSceneStandardPlacement) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UIWindowScenePlacement where Self == UIKit.UIWindowSceneStandardPlacement {
  public static func standard() -> Self
}
@available(iOS 17.0, visionOS 1.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension UIHoverStyle {
  @_Concurrency.MainActor(unsafe) public var effect: any UIKit.UIHoverEffect {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var shape: UIKit.UIShape? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) convenience public init(effect: some UIHoverEffect, shape: UIKit.UIShape? = nil)
  @_Concurrency.MainActor(unsafe) convenience public init(shape: UIKit.UIShape? = nil)
}
@available(*, unavailable)
extension UIHoverStyle : Swift.Sendable {
}
@available(iOS 17.0, tvOS 17.0, *)
public protocol UIWindowScenePlacement : Swift.Hashable {
}
@available(iOS 16.0, *)
extension UIPasteControl.Configuration {
  @_Concurrency.MainActor(unsafe) public var cornerStyle: UIButton.Configuration.CornerStyle {
    get
    set
  }
}
extension UIEdgeInsets : Swift.Equatable {
  @_transparent public static func == (lhs: UIEdgeInsets, rhs: UIEdgeInsets) -> Swift.Bool {
    return lhs.top == rhs.top &&
           lhs.left == rhs.left &&
           lhs.bottom == rhs.bottom &&
           lhs.right == rhs.right
  }
}
@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension NSDirectionalEdgeInsets : Swift.Equatable {
  @_transparent public static func == (lhs: NSDirectionalEdgeInsets, rhs: NSDirectionalEdgeInsets) -> Swift.Bool {
    return lhs.top == rhs.top &&
           lhs.leading == rhs.leading &&
           lhs.bottom == rhs.bottom &&
           lhs.trailing == rhs.trailing
  }
}
extension UIOffset : Swift.Equatable {
  @_transparent public static func == (lhs: UIOffset, rhs: UIOffset) -> Swift.Bool {
    return lhs.horizontal == rhs.horizontal &&
           lhs.vertical == rhs.vertical
  }
}
extension UIFloatRange : Swift.Equatable {
  @_transparent public static func == (lhs: UIFloatRange, rhs: UIFloatRange) -> Swift.Bool {
    return lhs.minimum == rhs.minimum &&
           lhs.maximum == rhs.maximum
  }
}
@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIEdgeInsetsEqualToEdgeInsets(_ insets1: UIEdgeInsets, _ insets2: UIEdgeInsets) -> Swift.Bool
@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIOffsetEqualToOffset(_ offset1: UIOffset, _ offset2: UIOffset) -> Swift.Bool
@available(swift, deprecated: 4.2, message: "Use == operator instead.")
public func UIFloatRangeIsEqualToRange(_ range: UIFloatRange, _ otherRange: UIFloatRange) -> Swift.Bool
extension UIEdgeInsets : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension NSDirectionalEdgeInsets : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension UIOffset : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension UIFloatRange : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(swift 4)
public protocol _UIKitNumericRawRepresentable : Swift.Comparable, Swift.RawRepresentable where Self.RawValue : Swift.Comparable, Self.RawValue : Swift.Numeric {
}
extension UIKit._UIKitNumericRawRepresentable {
  public static func < (lhs: Self, rhs: Self) -> Swift.Bool
  public static func + (lhs: Self, rhs: Self.RawValue) -> Self
  public static func + (lhs: Self.RawValue, rhs: Self) -> Self
  public static func - (lhs: Self, rhs: Self.RawValue) -> Self
  public static func - (lhs: Self, rhs: Self) -> Self.RawValue
  public static func += (lhs: inout Self, rhs: Self.RawValue)
  public static func -= (lhs: inout Self, rhs: Self.RawValue)
}
extension UIFont.Weight : UIKit._UIKitNumericRawRepresentable {
}
extension UIFont.Width : UIKit._UIKitNumericRawRepresentable {
}
extension UILayoutPriority : UIKit._UIKitNumericRawRepresentable {
}
extension UIWindow.Level : UIKit._UIKitNumericRawRepresentable {
}
@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isLandscape(self:)")
public func UIDeviceOrientationIsLandscape(_ orientation: UIDeviceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isPortrait(self:)")
public func UIDeviceOrientationIsPortrait(_ orientation: UIDeviceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isValidInterfaceOrientation(self:)")
public func UIDeviceOrientationIsValidInterfaceOrientation(_ orientation: UIDeviceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIInterfaceOrientation.isPortrait(self:)")
public func UIInterfaceOrientationIsPortrait(_ orientation: UIInterfaceOrientation) -> Swift.Bool
@available(swift, obsoleted: 4.2, renamed: "getter:UIInterfaceOrientation.isLandscape(self:)")
public func UIInterfaceOrientationIsLandscape(_ orientation: UIInterfaceOrientation) -> Swift.Bool
@available(iOS, introduced: 2.0, deprecated: 8.3, message: "UIActionSheet is deprecated. Use UIAlertController with a preferredStyle of UIAlertControllerStyleActionSheet instead")
@available(visionOS, unavailable)
extension UIActionSheet {
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String?, delegate: (any UIActionSheetDelegate)?, cancelButtonTitle: Swift.String?, destructiveButtonTitle: Swift.String?, otherButtonTitles firstButtonTitle: Swift.String, _ moreButtonTitles: Swift.String...)
}
@available(iOS, introduced: 2.0, deprecated: 9.0, message: "UIAlertView is deprecated. Use UIAlertController with a preferredStyle of UIAlertControllerStyleAlert instead")
@available(visionOS, unavailable)
extension UIAlertView {
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String, message: Swift.String, delegate: (any UIAlertViewDelegate)?, cancelButtonTitle: Swift.String?, otherButtonTitles firstButtonTitle: Swift.String, _ moreButtonTitles: Swift.String...)
}
extension UIView : Swift.__DefaultCustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UIView._defaultCustomPlaygroundQuickLook will be removed in a future Swift version")
  @_Concurrency.MainActor(unsafe) public var _defaultCustomPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
extension UIColor : Swift._ExpressibleByColorLiteral {
  @nonobjc required convenience public init(_colorLiteralRed red: Swift.Float, green: Swift.Float, blue: Swift.Float, alpha: Swift.Float)
}
public typealias _ColorLiteralType = UIColor
@available(iOS 17.0, tvOS 17.0, *)
extension UIColor {
  convenience public init(resource: DeveloperToolsSupport.ColorResource)
}
extension UIImage : Swift._ExpressibleByImageLiteral {
  required convenience public init(imageLiteralResourceName name: Swift.String)
}
public typealias _ImageLiteralType = UIImage
@available(iOS 17.0, tvOS 17.0, *)
extension UIImage {
  convenience public init(resource: DeveloperToolsSupport.ImageResource)
}
extension UIFont.TextStyle {
  @available(iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var metrics: UIFontMetrics {
    get
  }
}
@available(iOS 11.0, tvOS 11.0, *)
extension UIFocusEnvironment {
  @_Concurrency.MainActor(unsafe) public func contains(_ environment: any UIFocusEnvironment) -> Swift.Bool
}
@available(iOS 11.0, tvOS 11.0, *)
extension UIFocusItem {
  @_Concurrency.MainActor(unsafe) public var isFocused: Swift.Bool {
    get
  }
}
@available(iOS 11.0, *)
extension UIDragDropSession {
  @available(iOS 11.0, *)
  @_Concurrency.MainActor(unsafe) public func canLoadObjects<T>(ofClass: T.Type) -> Swift.Bool where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
@available(iOS 11.0, *)
extension UIDropSession {
  @available(iOS 11.0, *)
  @_Concurrency.MainActor(unsafe) public func loadObjects<T>(ofClass: T.Type, completion: @escaping ([T]) -> Swift.Void) -> Foundation.Progress where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
@available(iOS 11.0, *)
extension UIPasteConfiguration {
  @available(iOS 11.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init<T>(forAccepting _: T.Type) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
  @available(iOS 11.0, *)
  @_Concurrency.MainActor(unsafe) public func addTypeIdentifiers<T>(forAccepting aClass: T.Type) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
extension UIPasteboard {
  @available(iOS 11.0, *)
  public func setObjects<T>(_ objects: [T]) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderWriting
  @available(iOS 11.0, *)
  public func setObjects<T>(_ objects: [T], localOnly: Swift.Bool, expirationDate: Foundation.Date?) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderWriting
}
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.notAvailable.rawValue")
public let UIPrintingNotAvailableError: Swift.Int
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.noContent.rawValue")
public let UIPrintNoContentError: Swift.Int
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.unknownImageFormat.rawValue")
public let UIPrintUnknownImageFormatError: Swift.Int
@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.jobFailed.rawValue")
public let UIPrintJobFailedError: Swift.Int
@available(swift, deprecated: 4.2, message: "Use the overload of UIApplicationMain where the type of the second parameter is UnsafeMutablePointer<UnsafeMutablePointer<Int8>?>, which is the same as the type of CommandLine.unsafeArgv.")
public func UIApplicationMain(_ argc: Swift.Int32, _ argv: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Swift.Int8>>!, _ principalClassName: Swift.String?, _ delegateClassName: Swift.String?) -> Swift.Int32
extension UIApplicationDelegate {
  @_alwaysEmitIntoClient @_Concurrency.MainActor(unsafe) public static func main() {
    // Explicitly use the version of UIApplicationMain that was deprecated in Swift 4.2
    typealias _MainFunction =
      (Int32, UnsafeMutablePointer<UnsafeMutablePointer<Int8>>, String?, String?) -> Int32
    let _main = UIApplicationMain as _MainFunction
    
    // Convert the argument vector to `UnsafeMutablePointer<UnsafeMutablePointer<Int8>>`
    // This is a no-op for Swift versions < 4.2
    let argv = UnsafeMutableRawPointer(CommandLine.unsafeArgv)
      .bindMemory(to: UnsafeMutablePointer<Int8>.self, capacity: Int(CommandLine.argc))
    exit(_main(CommandLine.argc, argv, nil, NSStringFromClass(self)))
  }
}
extension UIStoryboard {
  @available(iOS 13.0, tvOS 13.0, *)
  @_Concurrency.MainActor(unsafe) public func instantiateInitialViewController<ViewController>(creator: ((Foundation.NSCoder) -> ViewController?)? = nil) -> ViewController? where ViewController : UIViewController
  @available(iOS 13.0, tvOS 13.0, *)
  @_Concurrency.MainActor(unsafe) public func instantiateViewController<ViewController>(identifier: Swift.String, creator: ((Foundation.NSCoder) -> ViewController?)? = nil) -> ViewController where ViewController : UIViewController
}
extension UIAccessibilityTraits : Swift.OptionSet {
  public typealias ArrayLiteralElement = UIAccessibilityTraits
  public typealias Element = UIAccessibilityTraits
}
extension UITextDirection {
  public static func storage(_ direction: UITextStorageDirection) -> UITextDirection
  public static func layout(_ direction: UITextLayoutDirection) -> UITextDirection
}
@available(iOS 13.0, tvOS 13.0, *)
@preconcurrency public struct NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> : @unchecked Swift.Sendable where SectionIdentifierType : Swift.Hashable, SectionIdentifierType : Swift.Sendable, ItemIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Sendable {
  public init()
  public var numberOfItems: Swift.Int {
    get
  }
  public var numberOfSections: Swift.Int {
    get
  }
  public var sectionIdentifiers: [SectionIdentifierType] {
    get
  }
  public var itemIdentifiers: [ItemIdentifierType] {
    get
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var reloadedSectionIdentifiers: [SectionIdentifierType] {
    get
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var reloadedItemIdentifiers: [ItemIdentifierType] {
    get
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var reconfiguredItemIdentifiers: [ItemIdentifierType] {
    get
  }
  public func numberOfItems(inSection identifier: SectionIdentifierType) -> Swift.Int
  public func itemIdentifiers(inSection identifier: SectionIdentifierType) -> [ItemIdentifierType]
  public func sectionIdentifier(containingItem identifier: ItemIdentifierType) -> SectionIdentifierType?
  public func indexOfItem(_ identifier: ItemIdentifierType) -> Swift.Int?
  public func indexOfSection(_ identifier: SectionIdentifierType) -> Swift.Int?
  public mutating func appendItems(_ identifiers: [ItemIdentifierType], toSection sectionIdentifier: SectionIdentifierType? = nil)
  public mutating func insertItems(_ identifiers: [ItemIdentifierType], beforeItem beforeIdentifier: ItemIdentifierType)
  public mutating func insertItems(_ identifiers: [ItemIdentifierType], afterItem afterIdentifier: ItemIdentifierType)
  public mutating func deleteItems(_ identifiers: [ItemIdentifierType])
  public mutating func deleteAllItems()
  public mutating func moveItem(_ identifier: ItemIdentifierType, beforeItem toIdentifier: ItemIdentifierType)
  public mutating func moveItem(_ identifier: ItemIdentifierType, afterItem toIdentifier: ItemIdentifierType)
  public mutating func reloadItems(_ identifiers: [ItemIdentifierType])
  @available(iOS 15.0, tvOS 15.0, *)
  public mutating func reconfigureItems(_ identifiers: [ItemIdentifierType])
  public mutating func appendSections(_ identifiers: [SectionIdentifierType])
  public mutating func insertSections(_ identifiers: [SectionIdentifierType], beforeSection toIdentifier: SectionIdentifierType)
  public mutating func insertSections(_ identifiers: [SectionIdentifierType], afterSection toIdentifier: SectionIdentifierType)
  public mutating func deleteSections(_ identifiers: [SectionIdentifierType])
  public mutating func moveSection(_ identifier: SectionIdentifierType, beforeSection toIdentifier: SectionIdentifierType)
  public mutating func moveSection(_ identifier: SectionIdentifierType, afterSection toIdentifier: SectionIdentifierType)
  public mutating func reloadSections(_ identifiers: [SectionIdentifierType])
}
@available(iOS 13.0, tvOS 13.0, *)
extension UIKit.NSDiffableDataSourceSnapshot : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSDiffableDataSourceSnapshotReference
  public static func _forceBridgeFromObjectiveC(_ input: NSDiffableDataSourceSnapshotReference, result: inout UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: NSDiffableDataSourceSnapshotReference, result: inout UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ snapshot: NSDiffableDataSourceSnapshotReference?) -> UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  public typealias _ObjectiveCType = NSDiffableDataSourceSnapshotReference
}
@available(iOS 13.0, tvOS 13.0, *)
@preconcurrency @_Concurrency.MainActor(unsafe) open class UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : ObjectiveC.NSObject, UICollectionViewDataSource where SectionIdentifierType : Swift.Hashable, SectionIdentifierType : Swift.Sendable, ItemIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Sendable {
  public typealias CellProvider = (_ collectionView: UICollectionView, _ indexPath: Foundation.IndexPath, _ itemIdentifier: ItemIdentifierType) -> UICollectionViewCell?
  public typealias SupplementaryViewProvider = (_ collectionView: UICollectionView, _ elementKind: Swift.String, _ indexPath: Foundation.IndexPath) -> UICollectionReusableView?
  @_Concurrency.MainActor(unsafe) public var supplementaryViewProvider: UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SupplementaryViewProvider? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public init(collectionView: UICollectionView, cellProvider: @escaping UIKit.UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.CellProvider)
  nonisolated open func apply(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func apply(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool = true) async
  #endif
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func applySnapshotUsingReloadData(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, completion: (() -> Swift.Void)? = nil)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func applySnapshotUsingReloadData(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>) async
  #endif
  nonisolated open func snapshot() -> UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) open func sectionIdentifier(for index: Swift.Int) -> SectionIdentifierType?
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) open func index(for sectionIdentifier: SectionIdentifierType) -> Swift.Int?
  @_Concurrency.MainActor(unsafe) open func itemIdentifier(for indexPath: Foundation.IndexPath) -> ItemIdentifierType?
  @_Concurrency.MainActor(unsafe) open func indexPath(for itemIdentifier: ItemIdentifierType) -> Foundation.IndexPath?
  @_Concurrency.MainActor(unsafe) @objc open func numberOfSections(in collectionView: UICollectionView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UICollectionViewCell
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: Swift.String, at indexPath: Foundation.IndexPath) -> UICollectionReusableView
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UICollectionView, canMoveItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: Foundation.IndexPath, to destinationIndexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc open func indexTitles(for collectionView: UICollectionView) -> [Swift.String]?
  @_Concurrency.MainActor(unsafe) @objc open func collectionView(_ collectionView: UICollectionView, indexPathForIndexTitle title: Swift.String, at index: Swift.Int) -> Foundation.IndexPath
  @_Concurrency.MainActor(unsafe) public func description() -> Swift.String
  @objc deinit
}
@available(iOS 13.0, tvOS 13.0, *)
@preconcurrency @_Concurrency.MainActor(unsafe) open class UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : ObjectiveC.NSObject, UITableViewDataSource where SectionIdentifierType : Swift.Hashable, SectionIdentifierType : Swift.Sendable, ItemIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Sendable {
  public typealias CellProvider = (_ tableView: UITableView, _ indexPath: Foundation.IndexPath, _ itemIdentifier: ItemIdentifierType) -> UITableViewCell?
  @_Concurrency.MainActor(unsafe) public init(tableView: UITableView, cellProvider: @escaping UIKit.UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.CellProvider)
  nonisolated open func apply(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func apply(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool = true) async
  #endif
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func applySnapshotUsingReloadData(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, completion: (() -> Swift.Void)? = nil)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, tvOS 15.0, *)
  nonisolated open func applySnapshotUsingReloadData(_ snapshot: UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>) async
  #endif
  nonisolated open func snapshot() -> UIKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) open func sectionIdentifier(for index: Swift.Int) -> SectionIdentifierType?
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) open func index(for sectionIdentifier: SectionIdentifierType) -> Swift.Int?
  @_Concurrency.MainActor(unsafe) open func itemIdentifier(for indexPath: Foundation.IndexPath) -> ItemIdentifierType?
  @_Concurrency.MainActor(unsafe) open func indexPath(for itemIdentifier: ItemIdentifierType) -> Foundation.IndexPath?
  @_Concurrency.MainActor(unsafe) public var defaultRowAnimation: UITableView.RowAnimation {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc open func numberOfSections(in tableView: UITableView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UITableViewCell
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UITableView, titleForHeaderInSection section: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UITableView, titleForFooterInSection section: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UITableView, canEditRowAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UITableView, canMoveRowAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: Foundation.IndexPath, to destinationIndexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc open func sectionIndexTitles(for tableView: UITableView) -> [Swift.String]?
  @_Concurrency.MainActor(unsafe) @objc open func tableView(_ tableView: UITableView, sectionForSectionIndexTitle title: Swift.String, at index: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) public func description() -> Swift.String
  @objc deinit
}
@available(iOS 13.0, *)
extension UICommand {
  @_disfavoredOverload @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", image: UIImage? = nil, action: ObjectiveC.Selector, propertyList: Any? = nil, alternates: [UICommandAlternate] = [], discoverabilityTitle: Swift.String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off)
  @available(iOS 15.0, tvOS 15.0, *)
  @_disfavoredOverload @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", subtitle: Swift.String? = nil, image: UIImage? = nil, action: ObjectiveC.Selector, propertyList: Any? = nil, alternates: [UICommandAlternate] = [], discoverabilityTitle: Swift.String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off)
}
@available(iOS 17.0, tvOS 17.0, *)
extension UICommand {
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", subtitle: Swift.String? = nil, image: UIImage? = nil, selectedImage: UIImage? = nil, action: ObjectiveC.Selector, propertyList: Any? = nil, alternates: [UICommandAlternate] = [], discoverabilityTitle: Swift.String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off)
}
@available(iOS 13.0, *)
extension UIKeyCommand {
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", image: UIImage? = nil, action: ObjectiveC.Selector, input: Swift.String, modifierFlags: UIKeyModifierFlags = [], propertyList: Any? = nil, alternates: [UICommandAlternate] = [], discoverabilityTitle: Swift.String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off)
}
@available(iOS 13.0, tvOS 14.0, *)
extension UIAction {
  @_disfavoredOverload @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", image: UIImage? = nil, identifier: UIAction.Identifier? = nil, discoverabilityTitle: Swift.String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off, handler: @escaping UIActionHandler)
  @available(iOS 15.0, tvOS 15.0, *)
  @_disfavoredOverload @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", subtitle: Swift.String? = nil, image: UIImage? = nil, identifier: UIAction.Identifier? = nil, discoverabilityTitle: Swift.String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off, handler: @escaping UIActionHandler)
  @available(iOS 17.0, tvOS 17.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", subtitle: Swift.String? = nil, image: UIImage? = nil, selectedImage: UIImage? = nil, identifier: UIAction.Identifier? = nil, discoverabilityTitle: Swift.String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off, handler: @escaping UIActionHandler)
}
@available(iOS 13.0, tvOS 14.0, *)
extension UIMenu {
  @_disfavoredOverload @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", image: UIImage? = nil, identifier: UIMenu.Identifier? = nil, options: UIMenu.Options = [], children: [UIMenuElement] = [])
  @available(iOS 15.0, tvOS 15.0, *)
  @_disfavoredOverload @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", subtitle: Swift.String? = nil, image: UIImage? = nil, identifier: UIMenu.Identifier? = nil, options: UIMenu.Options = [], children: [UIMenuElement] = [])
  @available(iOS 16.0, tvOS 16.0, *)
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String = "", subtitle: Swift.String? = nil, image: UIImage? = nil, identifier: UIMenu.Identifier? = nil, options: UIMenu.Options = [], preferredElementSize: UIMenu.ElementSize = { if #available(iOS 17.0, tvOS 17.0, *) { .automatic } else { .large } }(), children: [UIMenuElement] = [])
}
@available(iOS 13.0, tvOS 14.0, *)
extension UIMenuBuilder {
  @_Concurrency.MainActor(unsafe) public func command(for action: ObjectiveC.Selector, propertyList: Any? = nil) -> UICommand?
}
@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension UIImage {
  public var baselineOffsetFromBottom: CoreFoundation.CGFloat? {
    get
  }
}
@available(iOS 16.0, macCatalyst 16.0, tvOS 16.0, watchOS 9.0, *)
extension UIImage {
  convenience public init?(systemName name: Swift.String, variableValue: Swift.Double, configuration: UIImage.Configuration? = nil)
  convenience public init?(named name: Swift.String, in bundle: Foundation.Bundle? = nil, variableValue: Swift.Double, configuration: UIImage.Configuration? = nil)
}
@available(iOS 15.0, *)
extension UIWindowScene.ActivationConfiguration {
  convenience public init(userActivity: Foundation.NSUserActivity, options: UIWindowScene.ActivationRequestOptions? = nil, preview: UITargetedPreview? = nil)
}
@available(iOS 15.0, *)
extension UIWindowScene.ActivationAction {
  @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String? = nil, subtitle: Swift.String? = nil, image: UIImage? = nil, identifier: UIAction.Identifier? = nil, discoverabilityTitle: Swift.String? = nil, attributes: UIMenuElement.Attributes = [], alternate: UIAction? = nil, _ configuration: @escaping UIWindowScene.ActivationAction.ConfigurationProvider)
}
@available(iOS 13.0, tvOS 17.0, *)
extension UIContextMenuConfiguration {
  @_alwaysEmitIntoClient @_Concurrency.MainActor(unsafe) convenience public init(identifier: (any Foundation.NSCopying)? = nil, previewProvider: UIContextMenuContentPreviewProvider? = nil, actionProvider: UIContextMenuActionProvider? = nil) {
        self.init(__identifier: identifier,
                  previewProvider: previewProvider,
                  actionProvider: actionProvider)
    }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) @_Concurrency.MainActor(unsafe) dynamic open var configurationState: UIKit.UICellConfigurationState {
    @objc get
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) @_Concurrency.MainActor(unsafe) dynamic open func updateConfiguration(using state: UIKit.UICellConfigurationState)
  @available(iOS 15.0, tvOS 15.0, *)
  public typealias ConfigurationUpdateHandler = (_ cell: UICollectionViewCell, _ state: UIKit.UICellConfigurationState) -> Swift.Void
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) public var configurationUpdateHandler: UICollectionViewCell.ConfigurationUpdateHandler? {
    get
    set
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) @_Concurrency.MainActor(unsafe) dynamic open var configurationState: UIKit.UICellConfigurationState {
    @objc get
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) @_Concurrency.MainActor(unsafe) dynamic open func updateConfiguration(using state: UIKit.UICellConfigurationState)
  @available(iOS 15.0, tvOS 15.0, *)
  public typealias ConfigurationUpdateHandler = (_ cell: UITableViewCell, _ state: UIKit.UICellConfigurationState) -> Swift.Void
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) public var configurationUpdateHandler: UITableViewCell.ConfigurationUpdateHandler? {
    get
    set
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) @_Concurrency.MainActor(unsafe) dynamic open var configurationState: UIKit.UIViewConfigurationState {
    @objc get
  }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) @_Concurrency.MainActor(unsafe) dynamic open func updateConfiguration(using state: UIKit.UIViewConfigurationState)
  @available(iOS 15.0, tvOS 15.0, *)
  public typealias ConfigurationUpdateHandler = (_ headerFooterView: UITableViewHeaderFooterView, _ state: UIKit.UIViewConfigurationState) -> Swift.Void
  @available(iOS 15.0, tvOS 15.0, *)
  @_Concurrency.MainActor(unsafe) public var configurationUpdateHandler: UITableViewHeaderFooterView.ConfigurationUpdateHandler? {
    get
    set
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public protocol UIConfigurationState {
  init(traitCollection: UITraitCollection)
  var traitCollection: UITraitCollection { get set }
  subscript(key: UIConfigurationStateCustomKey) -> Swift.AnyHashable? { get set }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIViewConfigurationState : UIKit.UIConfigurationState, Swift.Hashable {
  public var traitCollection: UITraitCollection {
    get
    set
  }
  public var isDisabled: Swift.Bool {
    get
    set
  }
  public var isHighlighted: Swift.Bool {
    get
    set
  }
  public var isSelected: Swift.Bool {
    get
    set
  }
  public var isFocused: Swift.Bool {
    get
    set
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var isPinned: Swift.Bool {
    get
    set
  }
  public subscript(key: UIConfigurationStateCustomKey) -> Swift.AnyHashable? {
    get
    set
  }
  public init(traitCollection: UITraitCollection)
  public static func == (lhs: UIKit.UIViewConfigurationState, rhs: UIKit.UIViewConfigurationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UICellConfigurationState : UIKit.UIConfigurationState, Swift.Hashable {
  @available(iOS 14.0, *)
  public enum DragState : Swift.Hashable {
    case none
    case lifting
    case dragging
    public static func == (a: UIKit.UICellConfigurationState.DragState, b: UIKit.UICellConfigurationState.DragState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(iOS 14.0, *)
  public enum DropState : Swift.Hashable {
    case none
    case notTargeted
    case targeted
    public static func == (a: UIKit.UICellConfigurationState.DropState, b: UIKit.UICellConfigurationState.DropState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var traitCollection: UITraitCollection {
    get
    set
  }
  public var isDisabled: Swift.Bool {
    get
    set
  }
  public var isHighlighted: Swift.Bool {
    get
    set
  }
  public var isSelected: Swift.Bool {
    get
    set
  }
  public var isFocused: Swift.Bool {
    get
    set
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var isPinned: Swift.Bool {
    get
    set
  }
  public var isEditing: Swift.Bool {
    get
    set
  }
  public var isExpanded: Swift.Bool {
    get
    set
  }
  public var isSwiped: Swift.Bool {
    get
    set
  }
  public var isReordering: Swift.Bool {
    get
    set
  }
  public var cellDragState: UIKit.UICellConfigurationState.DragState {
    get
    set
  }
  public var cellDropState: UIKit.UICellConfigurationState.DropState {
    get
    set
  }
  public subscript(key: UIConfigurationStateCustomKey) -> Swift.AnyHashable? {
    get
    set
  }
  public init(traitCollection: UITraitCollection)
  public static func == (lhs: UIKit.UICellConfigurationState, rhs: UIKit.UICellConfigurationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIViewConfigurationState : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> __UIViewConfigurationState
  public static func _forceBridgeFromObjectiveC(_ input: __UIViewConfigurationState, result: inout UIKit.UIViewConfigurationState?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: __UIViewConfigurationState, result: inout UIKit.UIViewConfigurationState?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _state: __UIViewConfigurationState?) -> UIKit.UIViewConfigurationState
  public typealias _ObjectiveCType = __UIViewConfigurationState
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellConfigurationState : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> __UICellConfigurationState
  public static func _forceBridgeFromObjectiveC(_ input: __UICellConfigurationState, result: inout UIKit.UICellConfigurationState?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: __UICellConfigurationState, result: inout UIKit.UICellConfigurationState?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ _state: __UICellConfigurationState?) -> UIKit.UICellConfigurationState
  public typealias _ObjectiveCType = __UICellConfigurationState
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIViewConfigurationState : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellConfigurationState : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 17.0, *)
@available(tvOS, unavailable)
extension UITextItem {
  public enum Content {
    case link(Foundation.URL)
    case textAttachment(NSTextAttachment)
    case tag(Swift.String)
  }
  @_Concurrency.MainActor(unsafe) public var content: UITextItem.Content {
    get
  }
}
@available(iOS 17.0, *)
@available(tvOS, unavailable)
extension UITextItem.MenuConfiguration {
  public enum Preview {
    case `default`
    case view(UIView)
  }
  @_Concurrency.MainActor(unsafe) convenience public init(preview: UITextItem.MenuConfiguration.Preview? = .default, menu: UIMenu)
}
@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var backgroundConfiguration: UIKit.UIBackgroundConfiguration? {
    get
    set(backgroundConfiguration)
  }
  @available(iOS 16.0, tvOS 16.0, *)
  @_Concurrency.MainActor(unsafe) public func defaultBackgroundConfiguration() -> UIKit.UIBackgroundConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var backgroundConfiguration: UIKit.UIBackgroundConfiguration? {
    get
    set(backgroundConfiguration)
  }
  @available(iOS 16.0, tvOS 16.0, *)
  @_Concurrency.MainActor(unsafe) public func defaultBackgroundConfiguration() -> UIKit.UIBackgroundConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  @_Concurrency.MainActor(unsafe) public var backgroundConfiguration: UIKit.UIBackgroundConfiguration? {
    get
    set(backgroundConfiguration)
  }
  @available(iOS 16.0, tvOS 16.0, *)
  @_Concurrency.MainActor(unsafe) public func defaultBackgroundConfiguration() -> UIKit.UIBackgroundConfiguration
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIConfigurationColorTransformer {
  public let transform: (UIColor) -> UIColor
  public init(_ transform: @escaping (UIColor) -> UIColor)
  public func callAsFunction(_ input: UIColor) -> UIColor
  public static let grayscale: UIKit.UIConfigurationColorTransformer
  public static let preferredTint: UIKit.UIConfigurationColorTransformer
  public static let monochromeTint: UIKit.UIConfigurationColorTransformer
}
@available(iOS 14.0, tvOS 14.0, *)
public struct UIBackgroundConfiguration : Swift.Hashable {
  public static func clear() -> UIKit.UIBackgroundConfiguration
  public static func listPlainCell() -> UIKit.UIBackgroundConfiguration
  public static func listPlainHeaderFooter() -> UIKit.UIBackgroundConfiguration
  public static func listGroupedCell() -> UIKit.UIBackgroundConfiguration
  public static func listGroupedHeaderFooter() -> UIKit.UIBackgroundConfiguration
  public static func listSidebarHeader() -> UIKit.UIBackgroundConfiguration
  public static func listSidebarCell() -> UIKit.UIBackgroundConfiguration
  public static func listAccompaniedSidebarCell() -> UIKit.UIBackgroundConfiguration
  public func updated(for state: any UIKit.UIConfigurationState) -> UIKit.UIBackgroundConfiguration
  public var customView: UIView? {
    get
    set(view)
  }
  public var cornerRadius: CoreFoundation.CGFloat {
    get
    set(cornerRadius)
  }
  public var backgroundInsets: NSDirectionalEdgeInsets {
    get
    set(backgroundInsets)
  }
  public var edgesAddingLayoutMarginsToBackgroundInsets: NSDirectionalRectEdge {
    get
    set(backgroundInsets)
  }
  public var backgroundColor: UIColor? {
    get
    set(backgroundColor)
  }
  public var backgroundColorTransformer: UIKit.UIConfigurationColorTransformer? {
    get
    set(backgroundColorTransformer)
  }
  public func resolvedBackgroundColor(for tintColor: UIColor) -> UIColor
  public var visualEffect: UIVisualEffect? {
    get
    set(visualEffect)
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var image: UIImage? {
    get
    set(image)
  }
  @available(iOS 15.0, tvOS 15.0, *)
  public var imageContentMode: UIView.ContentMode {
    get
    set(imageContentMode)
  }
  public var strokeColor: UIColor? {
    get
    set(strokeColor)
  }
  public var strokeColorTransformer: UIKit.UIConfigurationColorTransformer? {
    get
    set(strokeColorTransformer)
  }
  public func resolvedStrokeColor(for tintColor: UIColor) -> UIColor
  public var strokeWidth: CoreFoundation.CGFloat {
    get
    set(strokeWidth)
  }
  public var strokeOutset: CoreFoundation.CGFloat {
    get
    set(strokeOutset)
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UIKit.UIBackgroundConfiguration, b: UIKit.UIBackgroundConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UIBackgroundConfiguration : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.DisplayedState : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.DisplayedState : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.OutlineDisclosureOptions.Style : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICellAccessory.OutlineDisclosureOptions.Style : Swift.Hashable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIButton.Configuration.Size : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIButton.Configuration.Size : Swift.Hashable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIButton.Configuration.TitleAlignment : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIButton.Configuration.TitleAlignment : Swift.Hashable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIButton.Configuration.CornerStyle : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIButton.Configuration.CornerStyle : Swift.Hashable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIButton.Configuration.MacIdiomStyle : Swift.Equatable {}
@available(iOS 15.0, tvOS 15.0, *)
extension UIButton.Configuration.MacIdiomStyle : Swift.Hashable {}
@available(iOS 16.0, tvOS 16.0, *)
extension UIButton.Configuration.Indicator : Swift.Equatable {}
@available(iOS 16.0, tvOS 16.0, *)
extension UIButton.Configuration.Indicator : Swift.Hashable {}
@available(iOS 17.0, tvOS 17.0, *)
extension UIKit.UISymbolEffectCompletionContext : Swift.Sendable {}
@available(iOS 13.4, *)
extension UIKit.UIPointerEffect.TintMode : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.Appearance : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.Appearance : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.HeaderMode : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.HeaderMode : Swift.Hashable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.FooterMode : Swift.Equatable {}
@available(iOS 14.0, tvOS 14.0, *)
extension UIKit.UICollectionLayoutListConfiguration.FooterMode : Swift.Hashable {}
