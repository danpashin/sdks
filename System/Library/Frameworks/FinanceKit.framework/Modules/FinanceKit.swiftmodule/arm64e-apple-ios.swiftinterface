// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.12.5 clang-1500.3.9.1.1)
// swift-module-flags: -target arm64e-apple-ios17.4 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-bare-slash-regex -user-module-version 144.30 -module-name FinanceKit
import CoreData
@_exported import FinanceKit
import Foundation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import _System_Foundation
@available(iOS 17, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore {
  public enum ContainsOrderResult : Swift.CaseIterable, Swift.Hashable, Swift.Sendable {
    case exists
    case notFound
    case newerExists
    case olderExists
    public static func == (a: FinanceKit.FinanceStore.ContainsOrderResult, b: FinanceKit.FinanceStore.ContainsOrderResult) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [FinanceKit.FinanceStore.ContainsOrderResult]
    public static var allCases: [FinanceKit.FinanceStore.ContainsOrderResult] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 17, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore {
  #if compiler(>=5.3) && $AsyncAwait
  public func containsOrder(matching fqoid: FinanceKit.FullyQualifiedOrderIdentifier, updatedDate: Foundation.Date? = nil) async throws -> FinanceKit.FinanceStore.ContainsOrderResult
  #endif
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct CurrencyAmount : Swift.Hashable, Swift.Sendable {
  public let amount: Foundation.Decimal
  public let currencyCode: Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: FinanceKit.CurrencyAmount, b: FinanceKit.CurrencyAmount) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore {
  #if compiler(>=5.3) && $RethrowsProtocol
  public func accountHistory(since token: FinanceKit.FinanceStore.HistoryToken? = nil, isMonitoring: Swift.Bool = true) -> FinanceKit.FinanceStore.History<FinanceKit.Account>
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func accounts(query: FinanceKit.AccountQuery) async throws -> [FinanceKit.Account]
  #endif
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct AccountQuery : @unchecked Swift.Sendable {
  #if compiler(>=5.3) && $ParameterPacks
  public init(sortDescriptors: [Foundation.SortDescriptor<FinanceKit.Account>] = [], predicate: Foundation.Predicate<FinanceKit.Account>? = nil, limit: Swift.Int? = nil, offset: Swift.Int? = nil)
  #endif
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct AccountBalanceQuery : @unchecked Swift.Sendable {
  #if compiler(>=5.3) && $ParameterPacks
  public init(sortDescriptors: [Foundation.SortDescriptor<FinanceKit.AccountBalance>] = [], predicate: Foundation.Predicate<FinanceKit.AccountBalance>? = nil, limit: Swift.Int? = nil, offset: Swift.Int? = nil)
  #endif
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.AccountBalanceQuery {
  #if compiler(>=5.3) && $ParameterPacks
  public static func predicate(availableSince startDate: Foundation.Date, until endDate: Foundation.Date? = nil) -> Foundation.Predicate<FinanceKit.AccountBalance>
  #endif
  #if compiler(>=5.3) && $ParameterPacks
  public static func predicate(bookedSince startDate: Foundation.Date, until endDate: Foundation.Date? = nil) -> Foundation.Predicate<FinanceKit.AccountBalance>
  #endif
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public enum Account : Swift.Codable, Swift.Equatable, Swift.Identifiable, Swift.Sendable {
  public var id: Foundation.UUID {
    get
  }
  public var displayName: Swift.String {
    get
  }
  public var accountDescription: Swift.String? {
    get
  }
  public var institutionName: Swift.String {
    get
  }
  public var currencyCode: Swift.String {
    get
  }
  case asset(FinanceKit.AssetAccount)
  case liability(FinanceKit.LiabilityAccount)
  public static func == (a: FinanceKit.Account, b: FinanceKit.Account) -> Swift.Bool
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.Account {
  public var liabilityAccount: FinanceKit.LiabilityAccount? {
    get
  }
  public var assetAccount: FinanceKit.AssetAccount? {
    get
  }
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct AccountCreditInformation : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let creditLimit: FinanceKit.CurrencyAmount?
  public let nextPaymentDueDate: Foundation.Date?
  public let minimumNextPaymentAmount: FinanceKit.CurrencyAmount?
  public let overduePaymentAmount: FinanceKit.CurrencyAmount?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: FinanceKit.AccountCreditInformation, b: FinanceKit.AccountCreditInformation) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct AssetAccount : Swift.Codable, Swift.Equatable, Swift.Identifiable, Swift.Sendable {
  public let id: Foundation.UUID
  public let displayName: Swift.String
  public let accountDescription: Swift.String?
  public let institutionName: Swift.String
  public let currencyCode: Swift.String
  public static func == (a: FinanceKit.AssetAccount, b: FinanceKit.AssetAccount) -> Swift.Bool
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct LiabilityAccount : Swift.Codable, Swift.Equatable, Swift.Identifiable, Swift.Sendable {
  public let id: Foundation.UUID
  public let displayName: Swift.String
  public let accountDescription: Swift.String?
  public let institutionName: Swift.String
  public let currencyCode: Swift.String
  public let creditInformation: FinanceKit.AccountCreditInformation
  public static func == (a: FinanceKit.LiabilityAccount, b: FinanceKit.LiabilityAccount) -> Swift.Bool
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 17, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore {
  public enum SaveOrderResult : Swift.CaseIterable, Swift.Hashable, Swift.Sendable {
    case added
    case cancelled
    case newerExisting
    public static func == (a: FinanceKit.FinanceStore.SaveOrderResult, b: FinanceKit.FinanceStore.SaveOrderResult) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [FinanceKit.FinanceStore.SaveOrderResult]
    public static var allCases: [FinanceKit.FinanceStore.SaveOrderResult] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 17, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore {
  #if compiler(>=5.3) && $AsyncAwait
  public func saveOrder(signedArchive: Foundation.Data) async throws -> FinanceKit.FinanceStore.SaveOrderResult
  #endif
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public enum CreditDebitIndicator : Swift.Int16, Swift.Codable, Swift.CaseIterable, Swift.Equatable, Swift.Sendable {
  case credit
  case debit
  public init?(rawValue: Swift.Int16)
  public typealias AllCases = [FinanceKit.CreditDebitIndicator]
  public typealias RawValue = Swift.Int16
  public static var allCases: [FinanceKit.CreditDebitIndicator] {
    get
  }
  public var rawValue: Swift.Int16 {
    get
  }
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct Balance : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public let amount: FinanceKit.CurrencyAmount
  public let asOfDate: Foundation.Date
  public let creditDebitIndicator: FinanceKit.CreditDebitIndicator
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: FinanceKit.Balance, b: FinanceKit.Balance) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public enum CurrentBalance : Swift.Codable, Swift.Hashable, Swift.Sendable {
  case available(FinanceKit.Balance)
  case booked(FinanceKit.Balance)
  case availableAndBooked(available: FinanceKit.Balance, booked: FinanceKit.Balance)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: FinanceKit.CurrentBalance, b: FinanceKit.CurrentBalance) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct AccountBalance : Swift.Codable, Swift.Equatable, Swift.Identifiable, Swift.Sendable {
  public let id: Foundation.UUID
  public let accountID: Foundation.UUID
  public let currentBalance: FinanceKit.CurrentBalance
  public static func == (a: FinanceKit.AccountBalance, b: FinanceKit.AccountBalance) -> Swift.Bool
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.AccountBalance {
  public var available: FinanceKit.Balance? {
    get
  }
  public var booked: FinanceKit.Balance? {
    get
  }
  public var currencyCode: Swift.String {
    get
  }
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore {
  public struct HistoryToken : Swift.Codable, @unchecked Swift.Sendable {
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
  }
  public struct Changes<Model> where Model : Swift.Identifiable {
    public let inserted: [Model]
    public let updated: [Model]
    public let deleted: [Model.ID]
    public let newToken: FinanceKit.FinanceStore.HistoryToken
  }
  #if compiler(>=5.3) && $RethrowsProtocol
  public struct History<Model> : _Concurrency.AsyncSequence, Swift.Sendable where Model : Swift.Identifiable {
    public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      #if compiler(>=5.3) && $AsyncAwait
      public func next() async throws -> FinanceKit.FinanceStore.Changes<Model>?
      #endif
      public typealias Element = FinanceKit.FinanceStore.Changes<Model>
    }
    public typealias AsyncIterator = FinanceKit.FinanceStore.History<Model>.Iterator
    public typealias Element = FinanceKit.FinanceStore.Changes<Model>
    public func makeAsyncIterator() -> FinanceKit.FinanceStore.History<Model>.Iterator
  }
  #endif
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore.Changes : Swift.Sendable where Model : Swift.Sendable, Model.ID : Swift.Sendable {
}
@available(iOS 17, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore {
  public enum DataType : Swift.Equatable, Swift.Sendable {
    case orders
    @available(iOS 17.4, *)
    @available(tvOS, unavailable)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    case financialData
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: FinanceKit.FinanceStore.DataType, b: FinanceKit.FinanceStore.DataType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 17, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore {
  public static func isDataAvailable(_ type: FinanceKit.FinanceStore.DataType) -> Swift.Bool
}
@available(iOS 17, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct FullyQualifiedOrderIdentifier : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public var orderTypeIdentifier: Swift.String
  public var orderIdentifier: Swift.String
  public init(orderTypeIdentifier: Swift.String, orderIdentifier: Swift.String)
  public static func == (a: FinanceKit.FullyQualifiedOrderIdentifier, b: FinanceKit.FullyQualifiedOrderIdentifier) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 17, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FullyQualifiedOrderIdentifier : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public enum AuthorizationStatus : Swift.Codable, Swift.Sendable {
  case notDetermined
  case denied
  case authorized
  public static func == (a: FinanceKit.AuthorizationStatus, b: FinanceKit.AuthorizationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers @available(iOS 17, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public class FinanceStore {
  public static let shared: FinanceKit.FinanceStore
  @objc deinit
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore {
  #if compiler(>=5.3) && $RethrowsProtocol
  public func transactionHistory(forAccountID accountID: Foundation.UUID, since token: FinanceKit.FinanceStore.HistoryToken? = nil, isMonitoring: Swift.Bool = true) -> FinanceKit.FinanceStore.History<FinanceKit.Transaction>
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func transactions(query: FinanceKit.TransactionQuery) async throws -> [FinanceKit.Transaction]
  #endif
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore {
  #if compiler(>=5.3) && $RethrowsProtocol
  public func accountBalanceHistory(forAccountID accountID: Foundation.UUID, since token: FinanceKit.FinanceStore.HistoryToken? = nil, isMonitoring: Swift.Bool = true) -> FinanceKit.FinanceStore.History<FinanceKit.AccountBalance>
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func accountBalances(query: FinanceKit.AccountBalanceQuery) async throws -> [FinanceKit.AccountBalance]
  #endif
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct TransactionQuery : @unchecked Swift.Sendable {
  #if compiler(>=5.3) && $ParameterPacks
  public init(sortDescriptors: [Foundation.SortDescriptor<FinanceKit.Transaction>] = [], predicate: Foundation.Predicate<FinanceKit.Transaction>? = nil, limit: Swift.Int? = nil, offset: Swift.Int? = nil)
  #endif
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.TransactionQuery {
  #if compiler(>=5.3) && $ParameterPacks
  public static func predicate(forMerchantCategoryCodes merchantCategoryCodes: [FinanceKit.MerchantCategoryCode]) -> Foundation.Predicate<FinanceKit.Transaction>
  #endif
  #if compiler(>=5.3) && $ParameterPacks
  public static func predicate(forStatuses statuses: [FinanceKit.TransactionStatus]) -> Foundation.Predicate<FinanceKit.Transaction>
  #endif
  #if compiler(>=5.3) && $ParameterPacks
  public static func predicate(forTransactionTypes transactionTypes: [FinanceKit.TransactionType]) -> Foundation.Predicate<FinanceKit.Transaction>
  #endif
}
@available(iOS 17, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public enum FinanceError : Foundation.CustomNSError, Foundation.LocalizedError, Swift.Equatable, Swift.Sendable {
  case dataRestricted(FinanceKit.FinanceStore.DataType)
  case unknown
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
  public static var errorDomain: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public static func == (a: FinanceKit.FinanceError, b: FinanceKit.FinanceError) -> Swift.Bool
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore {
  #if compiler(>=5.3) && $AsyncAwait
  public func authorizationStatus() async throws -> FinanceKit.AuthorizationStatus
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func requestAuthorization() async throws -> FinanceKit.AuthorizationStatus
  #endif
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public enum TransactionType : Swift.Int16, Swift.Codable, Swift.CaseIterable, Swift.Sendable {
  case unknown
  case adjustment
  case atm
  case billPayment
  case check
  case deposit
  case directDeposit
  case dividend
  case fee
  case interest
  case pointOfSale
  case transfer
  case withdrawal
  case standingOrder
  case directDebit
  case loan
  case refund
  public init?(rawValue: Swift.Int16)
  public typealias AllCases = [FinanceKit.TransactionType]
  public typealias RawValue = Swift.Int16
  public static var allCases: [FinanceKit.TransactionType] {
    get
  }
  public var rawValue: Swift.Int16 {
    get
  }
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct MerchantCategoryCode : Swift.Codable, Swift.Hashable, Swift.RawRepresentable, Swift.Sendable {
  public init(rawValue: Swift.Int16)
  public let rawValue: Swift.Int16
  public typealias RawValue = Swift.Int16
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.MerchantCategoryCode : Swift.LosslessStringConvertible {
  public init?(_ description: Swift.String)
  public var description: Swift.String {
    get
  }
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct Transaction : Swift.Codable, Swift.Equatable, Swift.Identifiable, Swift.Sendable {
  public let id: Foundation.UUID
  public let accountID: Foundation.UUID
  public let transactionAmount: FinanceKit.CurrencyAmount
  public let foreignCurrencyAmount: FinanceKit.CurrencyAmount?
  public let creditDebitIndicator: FinanceKit.CreditDebitIndicator
  public let transactionDescription: Swift.String
  public let originalTransactionDescription: Swift.String
  public let merchantCategoryCode: FinanceKit.MerchantCategoryCode?
  public let merchantName: Swift.String?
  public let transactionType: FinanceKit.TransactionType
  public let status: FinanceKit.TransactionStatus
  public let transactionDate: Foundation.Date
  public let postedDate: Foundation.Date?
  public static func == (a: FinanceKit.Transaction, b: FinanceKit.Transaction) -> Swift.Bool
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public enum TransactionStatus : Swift.Int16, Swift.Codable, Swift.CaseIterable, Swift.Sendable {
  case authorized
  case memo
  case pending
  case booked
  case rejected
  public init?(rawValue: Swift.Int16)
  public typealias AllCases = [FinanceKit.TransactionStatus]
  public typealias RawValue = Swift.Int16
  public static var allCases: [FinanceKit.TransactionStatus] {
    get
  }
  public var rawValue: Swift.Int16 {
    get
  }
}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.CreditDebitIndicator : Swift.Hashable {}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.CreditDebitIndicator : Swift.RawRepresentable {}
@available(iOS 17, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.FinanceStore.DataType : Swift.Hashable {}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.AuthorizationStatus : Swift.Equatable {}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.AuthorizationStatus : Swift.Hashable {}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.TransactionStatus : Swift.Equatable {}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.TransactionStatus : Swift.Hashable {}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.TransactionStatus : Swift.RawRepresentable {}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.TransactionType : Swift.Equatable {}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.TransactionType : Swift.Hashable {}
@available(iOS 17.4, *)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension FinanceKit.TransactionType : Swift.RawRepresentable {}
